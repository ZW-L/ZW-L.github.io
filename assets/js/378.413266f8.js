(window.webpackJsonp=window.webpackJsonp||[]).push([[378],{808:function(e,t,v){"use strict";v.r(t);var _=v(25),s=Object(_.a)({},(function(){var e=this,t=e.$createElement,v=e._self._c||t;return v("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[v("h2",{attrs:{id:"简介"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#简介"}},[e._v("#")]),e._v(" 简介")]),e._v(" "),v("ul",[v("li",[v("a",{attrs:{href:"http://nodejs.cn/api/http.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("http"),v("OutboundLink")],1),e._v(" 模块用于实现 HTTP 服务器和客户端")])]),e._v(" "),v("h2",{attrs:{id:"api"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#api"}},[e._v("#")]),e._v(" API")]),e._v(" "),v("h3",{attrs:{id:"属性"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#属性"}},[e._v("#")]),e._v(" 属性")]),e._v(" "),v("ul",[v("li",[v("code",[e._v("http.METHODS: string[]")]),e._v("：解析器支持的 HTTP 方法列表")]),e._v(" "),v("li",[v("code",[e._v("http.STATUS_CODES: object")]),e._v("：所有标准 HTTP 响应状态码的集合，以及每个状态码的简短描述")]),e._v(" "),v("li",[v("code",[e._v("http.globalAgent: Agent")]),e._v("：Agent 的全局实例，作为所有 HTTP 客户端请求的默认值")]),e._v(" "),v("li",[v("code",[e._v("http.maxHeaderSize: number")]),e._v("：设置 HTTP 消息头的最大容量（以字节为单位，默认 8KB）")])]),e._v(" "),v("h3",{attrs:{id:"方法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#方法"}},[e._v("#")]),e._v(" 方法")]),e._v(" "),v("ul",[v("li",[v("code",[e._v("http.createServer(options?: object, requestListener?: function): Server")]),e._v("：创建一个 HTTP 服务器")]),e._v(" "),v("li",[v("code",[e._v("http.get(options: object, callback?: function): ClientRequest")]),e._v("：")]),e._v(" "),v("li",[v("code",[e._v("http.get(url: string, options: object, callback?: function): ClientRequest")]),e._v("：")]),e._v(" "),v("li",[v("code",[e._v("http.request(options: object, callback?: function): ClientRequest")]),e._v("：")]),e._v(" "),v("li",[v("code",[e._v("http.request(url: string, options: object, callback?: function): ClientRequest")]),e._v("：")]),e._v(" "),v("li",[v("code",[e._v("http.validateHeaderName(name)")]),e._v("：")]),e._v(" "),v("li",[v("code",[e._v("http.validateHeaderValue(name, value)")]),e._v("：")])]),e._v(" "),v("div",{staticClass:"custom-block tip"},[v("p",{staticClass:"custom-block-title"},[e._v("说明：")]),e._v(" "),v("ul",[v("li",[v("code",[e._v("createServer()")]),e._v(" 方法的 options 参数选项取值：\n"),v("ul",[v("li",[v("code",[e._v("IncomingMessage=IncomingMessage: IncomingMessage")]),e._v("：指定使用的 "),v("code",[e._v("IncomingMessage")]),e._v(" 类")]),e._v(" "),v("li",[v("code",[e._v("ServerResponse=ServerResponse: ServerResponse")]),e._v("：指定使用的 "),v("code",[e._v("ServerResponse")]),e._v(" 类")])])]),e._v(" "),v("li",[v("code",[e._v("get()")]),e._v("/"),v("code",[e._v("request()")]),e._v(" 方法返回的 "),v("code",[e._v("ClientRequest")]),e._v(" 对象是一个可写流，它们的 options 参数选项可取以下值：\n"),v("ul",[v("li",[v("code",[e._v("agent=undefined: Agent | false")]),e._v("：控制 Agent 的行为")]),e._v(" "),v("li",[v("code",[e._v("createConnection: function")]),e._v("：当 agent 选项未被使用时，用来为请求生成套接字或流的函数")]),e._v(" "),v("li",[v("code",[e._v("family: 4 | 6")]),e._v("：IP 地址版本，默认同时使用 IPv4 和 IPv6")]),e._v(" "),v("li",[v("code",[e._v("auth: string")]),e._v("：基本的身份认证")]),e._v(" "),v("li",[v("code",[e._v("headers: object")]),e._v("：请求头对象")]),e._v(" "),v("li",[v("code",[e._v("host=localhost: string")]),e._v("：服务器域名或 IP 地址")]),e._v(" "),v("li",[v("code",[e._v("hostname: string")]),e._v("：等同于 host，但优先级高于 host")]),e._v(" "),v("li",[v("code",[e._v("localAddress: string")]),e._v("：网络连接绑定的本地接口")]),e._v(" "),v("li",[v("code",[e._v("method=GET: string")]),e._v("：HTTP 请求方法")]),e._v(" "),v("li",[v("code",[e._v("path=/: string")]),e._v("：请求的路径")]),e._v(" "),v("li",[v("code",[e._v("defaultPort: number")]),e._v("：端口号")]),e._v(" "),v("li",[v("code",[e._v("port=defaultPort | 80: number")]),e._v("：远程服务器的端口")]),e._v(" "),v("li",[v("code",[e._v("protocol=http: string")]),e._v("：使用的协议")]),e._v(" "),v("li",[v("code",[e._v("setHost=true: boolean")]),e._v("：指定是否自动添加 Host 请求头")]),e._v(" "),v("li",[v("code",[e._v("socketPath: string")]),e._v("：Unix 域套接字")]),e._v(" "),v("li",[v("code",[e._v("timeout: number")]),e._v("：套接字超时时间（单位为毫秒）")])])]),e._v(" "),v("li",[v("code",[e._v("get()")]),e._v(" 方法中 options 参数的 method 值始终为 "),v("code",[e._v("GET")]),e._v("，并且会自动调用 "),v("code",[e._v("req.end()")]),e._v("；但 "),v("code",[e._v("request()")]),e._v(" 方法需要手动调用 "),v("code",[e._v("req.end()")]),e._v(" 方法")])])]),e._v(" "),v("h2",{attrs:{id:"http-agent-类"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#http-agent-类"}},[e._v("#")]),e._v(" http.Agent 类")]),e._v(" "),v("ul",[v("li",[v("code",[e._v("Agent")]),e._v(" 负责管理 HTTP 客户端的连接持久性和重用")]),e._v(" "),v("li",[e._v("它为给定的主机和端口维护一个待处理请求队列，为每个请求重用单独的套接字连接，直到队列为空，此时套接字被销毁或放入连接池，以便再次用于请求到同一个主机和端口")]),e._v(" "),v("li",[e._v("销毁还是放入连接池取决于 keepAlive 选项")]),e._v(" "),v("li",[e._v("创建一个 Agent 实例："),v("code",[e._v("new Agent(options?: object): Agent")])])]),e._v(" "),v("div",{staticClass:"custom-block tip"},[v("p",{staticClass:"custom-block-title"},[e._v("options 参数选项取值：")]),e._v(" "),v("ul",[v("li",[v("code",[e._v("keepAlive=false: boolean")]),e._v("：设置为 true 时将来再次发出请求无需重新建立 TCP 连接")]),e._v(" "),v("li",[v("code",[e._v("keepAliveMsecs=1000: number")]),e._v("：指定用于 TCP Keep-Alive 数据包的初始延迟（keepAlive 为 true 时才生效）")]),e._v(" "),v("li",[v("code",[e._v("maxFreeSockets=256: number")]),e._v("：在空闲状态下保持打开的套接字的最大数量（keepAlive 为 true 时才生效）")]),e._v(" "),v("li",[v("code",[e._v("maxSockets=Infinity: number")]),e._v("：每个主机允许的套接字的最大数量")]),e._v(" "),v("li",[v("code",[e._v("timeout: number")]),e._v("：套接字的超时时间（单位为毫秒）")])])]),e._v(" "),v("h3",{attrs:{id:"属性-2"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#属性-2"}},[e._v("#")]),e._v(" 属性")]),e._v(" "),v("ul",[v("li",[v("code",[e._v("agent.maxFreeSockets=256: number")]),e._v("：在空闲状态下保持打开的套接字的最大数量")]),e._v(" "),v("li",[v("code",[e._v("agent.maxSockets=Infinity: number")]),e._v("：每个主机允许的套接字的最大数量")]),e._v(" "),v("li",[v("code",[e._v("agent.freeSockets: object")]),e._v("：包含当启用 keepAlive 时代理正在等待使用的套接字数组")]),e._v(" "),v("li",[v("code",[e._v("agent.requests: object")]),e._v("：包含尚未分配给套接字的请求队列")]),e._v(" "),v("li",[v("code",[e._v("agent.sockets: object")]),e._v("：包含当前代理正在使用的套接字数组")])]),e._v(" "),v("h3",{attrs:{id:"方法-2"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#方法-2"}},[e._v("#")]),e._v(" 方法")]),e._v(" "),v("ul",[v("li",[v("code",[e._v("agent.createConnection(options[, callback])")]),e._v("：生成用于 HTTP 请求的套接字或流")]),e._v(" "),v("li",[v("code",[e._v("agent.keepSocketAlive(socket)")]),e._v("：当 socket 与请求分离并且可以由 Agent 保留时调用")]),e._v(" "),v("li",[v("code",[e._v("agent.reuseSocket(socket, request)")]),e._v("：由于 keep-alive 选项而在持久化后将 socket 附加到 request 时调用")]),e._v(" "),v("li",[v("code",[e._v("agent.destroy()")]),e._v("：销毁代理当前使用的所有套接字")]),e._v(" "),v("li",[v("code",[e._v("agent.getName(options)")]),e._v("：获取一组请求选项的唯一名称")])]),e._v(" "),v("h2",{attrs:{id:"http-server-类"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#http-server-类"}},[e._v("#")]),e._v(" http.Server 类")]),e._v(" "),v("ul",[v("li",[e._v("继承自 "),v("code",[e._v("net.Server")])])]),e._v(" "),v("h3",{attrs:{id:"事件"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#事件"}},[e._v("#")]),e._v(" 事件")]),e._v(" "),v("ul",[v("li",[v("code",[e._v("request")]),e._v("：有请求时触发(每个连接可能有多个请求)")]),e._v(" "),v("li",[v("code",[e._v("close")]),e._v("：服务器关闭时触发")]),e._v(" "),v("li",[v("code",[e._v("connect")]),e._v("：客户端请求 HTTP CONNECT 方法时触发，未监听此事件时客户端将关闭其连接")]),e._v(" "),v("li",[v("code",[e._v("connection")]),e._v("：建立新的 TCP 流时触发")]),e._v(" "),v("li",[v("code",[e._v("upgrade")]),e._v("：客户端请求 HTTP 升级时触发")]),e._v(" "),v("li",[v("code",[e._v("clientError")]),e._v("：客户端连接触发 "),v("code",[e._v("error")]),e._v(" 事件时触发")]),e._v(" "),v("li",[v("code",[e._v("checkContinue")]),e._v("：每次收到 "),v("code",[e._v("HTTP Expect: 100-continue")]),e._v(" 的请求时都会触发，未监听此事件时服务器将自动响应 "),v("code",[e._v("100 Continue")])]),e._v(" "),v("li",[v("code",[e._v("checkExpectation")]),e._v("：每次收到带有 "),v("code",[e._v("HTTP Expect")]),e._v(" 请求头的请求时触发(其值不是 "),v("code",[e._v("100-continue")]),e._v(")，未监听此事件时服务器将根据需要自动响应 "),v("code",[e._v("417 Expectation Failed")])])]),e._v(" "),v("h3",{attrs:{id:"属性-3"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#属性-3"}},[e._v("#")]),e._v(" 属性")]),e._v(" "),v("ul",[v("li",[v("code",[e._v("server.headersTimeout")]),e._v("：限制解析器等待接收完整 HTTP 请求头的时间")]),e._v(" "),v("li",[v("code",[e._v("server.listening")]),e._v("：表明服务器是否正在监听连接")]),e._v(" "),v("li",[v("code",[e._v("server.maxHeadersCount")]),e._v("：最大传入请求头数")]),e._v(" "),v("li",[v("code",[e._v("server.timeout")]),e._v("：认定套接字超时的不活动毫秒数")]),e._v(" "),v("li",[v("code",[e._v("server.requestTimeout")]),e._v("：请求超时时间")]),e._v(" "),v("li",[v("code",[e._v("server.keepAliveTimeout")]),e._v("：服务器在完成写入最后一个响应之后，在销毁套接字之前需要等待其他传入数据的非活动毫秒数")])]),e._v(" "),v("h3",{attrs:{id:"方法-3"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#方法-3"}},[e._v("#")]),e._v(" 方法")]),e._v(" "),v("ul",[v("li",[v("code",[e._v("server.close([callback])")]),e._v("：停止服务器接受新连接")]),e._v(" "),v("li",[v("code",[e._v("server.listen()")]),e._v("：启动 HTTP 服务器用于监听连接")]),e._v(" "),v("li",[v("code",[e._v("server.setTimeout([msecs][, callback])")]),e._v("：设置套接字的超时值，并触发 "),v("code",[e._v("timeout")]),e._v(" 事件")])]),e._v(" "),v("h2",{attrs:{id:"http-serverresponse-类"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#http-serverresponse-类"}},[e._v("#")]),e._v(" http.ServerResponse 类")]),e._v(" "),v("ul",[v("li",[e._v("继承自 "),v("code",[e._v("Stream")])]),e._v(" "),v("li",[e._v("由 HTTP 服务器在内部创建，而不是由用户创建，它会作为第二个参数传给 "),v("code",[e._v("request")]),e._v(" 事件")])]),e._v(" "),v("h3",{attrs:{id:"事件-2"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#事件-2"}},[e._v("#")]),e._v(" 事件")]),e._v(" "),v("ul",[v("li",[v("code",[e._v("close")]),e._v("：在响应完成之前触发(表明响应已完成，或者其底层的连接过早被终止)")]),e._v(" "),v("li",[v("code",[e._v("finish")]),e._v("：响应发送后触发(但并不意味着客户端已收到任何信息)")])]),e._v(" "),v("h3",{attrs:{id:"属性-4"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#属性-4"}},[e._v("#")]),e._v(" 属性")]),e._v(" "),v("ul",[v("li",[v("code",[e._v("res.connection")]),e._v("：")]),e._v(" "),v("li",[v("code",[e._v("res.finished")]),e._v("：")]),e._v(" "),v("li",[v("code",[e._v("res.headersSent")]),e._v("：如果已发送响应头，则为 true")]),e._v(" "),v("li",[v("code",[e._v("res.sendDate")]),e._v("：默认为 true，Date 响应头将自动生成并在响应中发送(如果响应头中尚不存在)")]),e._v(" "),v("li",[v("code",[e._v("res.socket")]),e._v("：指向底层的套接字")]),e._v(" "),v("li",[v("code",[e._v("res.statusCode")]),e._v("：控制在刷新响应头时将发送到客户端的状态码")]),e._v(" "),v("li",[v("code",[e._v("res.statusMessage")]),e._v("：控制在刷新响应头时将发送到客户端的状态消息")]),e._v(" "),v("li",[v("code",[e._v("res.writableEnded")]),e._v("：在调用 "),v("code",[e._v("response.end()")]),e._v(" 之后为 true")]),e._v(" "),v("li",[v("code",[e._v("res.writableFinished")]),e._v("：在触发 "),v("code",[e._v("finish")]),e._v(" 事件之前且所有数据都已刷新到底层的系统时为 true")])]),e._v(" "),v("h3",{attrs:{id:"方法-4"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#方法-4"}},[e._v("#")]),e._v(" 方法")]),e._v(" "),v("ul",[v("li",[v("code",[e._v("res.addTrailers(headers)")]),e._v("：将 HTTP 尾部响应头添加到响应中")])]),e._v(" "),v("div",{staticClass:"language-js extra-class"},[v("pre",{pre:!0,attrs:{class:"language-js"}},[v("code",[v("span",{pre:!0,attrs:{class:"token comment"}},[e._v("/* 注意：\n  1. 只有在使用分块编码进行响应时才会发出尾部响应头; 如果不是(如请求是 HTTP/1.0)，它们将被静默丢弃\n  2. HTTP 需要先发送 Trailer 响应头才能发出尾部响应头\n*/")]),e._v("\nres"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),v("span",{pre:!0,attrs:{class:"token function"}},[e._v("writeHead")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),v("span",{pre:!0,attrs:{class:"token number"}},[e._v("200")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" "),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v(" "),v("span",{pre:!0,attrs:{class:"token string"}},[e._v("'Content-Type'")]),v("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),v("span",{pre:!0,attrs:{class:"token string"}},[e._v("'text/plain'")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" "),v("span",{pre:!0,attrs:{class:"token string"}},[e._v("'Trailer'")]),v("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),v("span",{pre:!0,attrs:{class:"token string"}},[e._v("'Content-MD5'")]),e._v(" "),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v("\nres"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),v("span",{pre:!0,attrs:{class:"token function"}},[e._v("write")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("fileData"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v("\nres"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),v("span",{pre:!0,attrs:{class:"token function"}},[e._v("addTrailers")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v(" "),v("span",{pre:!0,attrs:{class:"token string"}},[e._v("'Content-MD5'")]),v("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),v("span",{pre:!0,attrs:{class:"token string"}},[e._v("'7895bf4b8828b55ceaf47747b4bca667'")]),e._v(" "),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v("\nres"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),v("span",{pre:!0,attrs:{class:"token function"}},[e._v("end")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v("\n")])])]),v("ul",[v("li",[v("code",[e._v("res.cork()")]),e._v("：类似 "),v("code",[e._v("writable.cork()")])]),e._v(" "),v("li",[v("code",[e._v("res.uncork()")]),e._v("：类似 "),v("code",[e._v("writable.uncork()")])]),e._v(" "),v("li",[v("code",[e._v("res.end([data[, encoding]][, callback])")]),e._v("：向服务器发出信号，表明已发送所有响应头和主体，该服务器应该视为此消息已完成；必须在每个响应上调用此方法")]),e._v(" "),v("li",[v("code",[e._v("res.flushHeaders()")]),e._v("：刷新响应头")]),e._v(" "),v("li",[v("code",[e._v("res.getHeader(name)")]),e._v("：读出已排队但未发送到客户端的响应头(不区分大小写)")]),e._v(" "),v("li",[v("code",[e._v("res.getHeaderNames()")]),e._v("：返回一个包含当前传出的响应头的唯一名称(所有响应头名称都是小写的)的数组")]),e._v(" "),v("li",[v("code",[e._v("res.getHeaders()")]),e._v("：返回当前传出的响应头的浅拷贝(所有响应头名称都是小写的)")]),e._v(" "),v("li",[v("code",[e._v("res.hasHeader(name)")]),e._v("：判断是否包含指定响应头(不区分大小写)")]),e._v(" "),v("li",[v("code",[e._v("res.removeHeader(name)")]),e._v("：移除排队等待中的隐式发送的响应头")]),e._v(" "),v("li",[v("code",[e._v("res.setHeader(name, value)")]),e._v("：设置单个响应头(优先级低于 "),v("code",[e._v("res.writeHead()")]),e._v(")")]),e._v(" "),v("li",[v("code",[e._v("res.setTimeout(msecs[, callback])")]),e._v("：设置套接字的超时值")]),e._v(" "),v("li",[v("code",[e._v("res.write(chunk[, encoding][, callback])")]),e._v("：发送一块响应主体，可以多次调用该方法以提供连续的响应主体片段")]),e._v(" "),v("li",[v("code",[e._v("res.writeHead(statusCode[, statusMessage][, headers]): ServerResponse")]),e._v("：向请求发送响应头(只能在消息上调用一次)")]),e._v(" "),v("li",[v("code",[e._v("res.writeContinue()")]),e._v("：向客户端发送 "),v("code",[e._v("HTTP/1.1 100 Continue")]),e._v(" 消息，表示应发送请求主体")]),e._v(" "),v("li",[v("code",[e._v("res.writeProcessing()")]),e._v("：向客户端发送 "),v("code",[e._v("HTTP/1.1 102 Processing")]),e._v(" 消息，表明可以发送请求主体")])]),e._v(" "),v("h2",{attrs:{id:"http-clientrequest-类"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#http-clientrequest-类"}},[e._v("#")]),e._v(" http.ClientRequest 类")]),e._v(" "),v("ul",[v("li",[e._v("继承自 "),v("code",[e._v("Stream")])]),e._v(" "),v("li",[e._v("由 "),v("code",[e._v("http.request()")]),e._v(" 创建并返回，代表正在进行中的请求，其请求头已进入队列")]),e._v(" "),v("li",[e._v("要为请求对象添加 "),v("code",[e._v("response")]),e._v(" 事件监听以获得响应，否则响应将会被完全地丢弃")]),e._v(" "),v("li",[e._v("如果响应过早关闭，则 "),v("code",[e._v("response")]),e._v(" 会触发 "),v("code",[e._v("aborted")]),e._v(" 事件而不是 "),v("code",[e._v("error")]),e._v(" 事件")])]),e._v(" "),v("h3",{attrs:{id:"事件-3"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#事件-3"}},[e._v("#")]),e._v(" 事件")]),e._v(" "),v("ul",[v("li",[v("code",[e._v("abort")]),e._v("：当请求被客户端中止时触发")]),e._v(" "),v("li",[v("code",[e._v("connect")]),e._v("：当服务器使用 "),v("code",[e._v("CONNECT")]),e._v(" 方法响应请求时都会触发")]),e._v(" "),v("li",[v("code",[e._v("continue")]),e._v("：当服务器发送 100 Continue HTTP 响应时触发")]),e._v(" "),v("li",[v("code",[e._v("information")]),e._v("：当服务器发送 1xx 中间响应（不包括 101 Upgrade）时触发")]),e._v(" "),v("li",[v("code",[e._v("response")]),e._v("：当收到此请求的响应时触发（仅触发一次）")]),e._v(" "),v("li",[v("code",[e._v("socket")]),e._v("：将套接字分配给此请求后触发")]),e._v(" "),v("li",[v("code",[e._v("timeout")]),e._v("：当底层套接字因不活动而超时时触发")]),e._v(" "),v("li",[v("code",[e._v("upgrade")]),e._v("：每次服务器响应升级请求时触发")])]),e._v(" "),v("h3",{attrs:{id:"属性-5"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#属性-5"}},[e._v("#")]),e._v(" 属性")]),e._v(" "),v("ul",[v("li",[v("code",[e._v("res.aborted: boolean")]),e._v("：指示请求是否已终止")]),e._v(" "),v("li",[v("code",[e._v("res.connection")]),e._v("：")]),e._v(" "),v("li",[v("code",[e._v("res.finished: boolean")]),e._v("：在调用 "),v("code",[e._v("res.end()")]),e._v(" 之后为 true")]),e._v(" "),v("li",[v("code",[e._v("res.maxHeadersCount=2000: number")]),e._v("：最大响应头数")]),e._v(" "),v("li",[v("code",[e._v("res.path: string")]),e._v("：请求的路径")]),e._v(" "),v("li",[v("code",[e._v("res.socket")]),e._v("：指向底层套接字")]),e._v(" "),v("li",[v("code",[e._v("res.writableEnded")]),e._v("：在调用 "),v("code",[e._v("res.end()")]),e._v(" 之后为 true")]),e._v(" "),v("li",[v("code",[e._v("res.writableFinished")]),e._v("：如果在触发 "),v("code",[e._v("finish")]),e._v(" 事件之前所有数据都已刷新到底层系统，则为 true")])]),e._v(" "),v("h3",{attrs:{id:"方法-5"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#方法-5"}},[e._v("#")]),e._v(" 方法")]),e._v(" "),v("ul",[v("li",[v("code",[e._v("res.abort()")]),e._v("：将请求标记为中止，响应中剩余的数据会被丢弃且套接字被销毁")]),e._v(" "),v("li",[v("code",[e._v("res.flushHeaders()")]),e._v("：刷新请求头")]),e._v(" "),v("li",[v("code",[e._v("res.getHeader(name: string): any")]),e._v("：读取请求中的一个请求头")]),e._v(" "),v("li",[v("code",[e._v("res.setHeader(name: string, value: any)")]),e._v("：设置单个请求头")]),e._v(" "),v("li",[v("code",[e._v("res.removeHeader(name: string)")]),e._v("：删除指定请求头")]),e._v(" "),v("li",[v("code",[e._v("res.end(data?: string | Buffer, encoding?: string, callback?: function): this")]),e._v("：完成发送请求，若部分请求主体还未发送，则将它们刷新到流中")]),e._v(" "),v("li",[v("code",[e._v("res.write(chunk?: string | Buffer, encoding: string, callback?: function)")]),e._v("：发送一个请求主体的数据块")]),e._v(" "),v("li",[v("code",[e._v("res.setNoDelay(noDelay?: boolean)")]),e._v("：一旦将套接字分配给此请求并且连接了套接字，便立即调用 "),v("code",[e._v("socket.setNoDelay()")])]),e._v(" "),v("li",[v("code",[e._v("res.setSocketKeepAlive(enable?: boolean, initialDelay: number)")]),e._v("：一旦将套接字分配给此请求并连接了套接字，便立即调用 "),v("code",[e._v("socket.setKeepAlive()")])]),e._v(" "),v("li",[v("code",[e._v("res.setTimeout(timeout?: number, callback?: function): ClientRequest")]),e._v("：一旦将套接字分配给此请求并且连接了套接字，便立即调用 socket.setTimeout()")])]),e._v(" "),v("h2",{attrs:{id:"http-incomingmessage-类"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#http-incomingmessage-类"}},[e._v("#")]),e._v(" http.IncomingMessage 类")]),e._v(" "),v("ul",[v("li",[e._v("继承自 "),v("code",[e._v("stream.Readable")])]),e._v(" "),v("li",[e._v("由 "),v("code",[e._v("http.Server")]),e._v(" 或 "),v("code",[e._v("http.ClientRequest")]),e._v(" 创建，并分别作为第一个参数传给 "),v("code",[e._v("request")]),e._v(" 和 "),v("code",[e._v("response")]),e._v(" 事件")]),e._v(" "),v("li",[e._v("可用于访问响应状态、消息头、以及数据")])]),e._v(" "),v("h3",{attrs:{id:"事件-4"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#事件-4"}},[e._v("#")]),e._v(" 事件")]),e._v(" "),v("ul",[v("li",[v("code",[e._v("aborted")]),e._v("：请求中止时触发")]),e._v(" "),v("li",[v("code",[e._v("close")]),e._v("：底层连接已关闭触发")])]),e._v(" "),v("h3",{attrs:{id:"属性-6"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#属性-6"}},[e._v("#")]),e._v(" 属性")]),e._v(" "),v("ul",[v("li",[v("code",[e._v("message.aborted")]),e._v("：如果请求已中止，则为 true")]),e._v(" "),v("li",[v("code",[e._v("message.complete")]),e._v("：已收到并成功解析完整的 HTTP 消息，则为 true")]),e._v(" "),v("li",[v("code",[e._v("message.headers")]),e._v("：请求或响应的消息头对象")]),e._v(" "),v("li",[v("code",[e._v("message.httpVersion")]),e._v("：服务器请求的时表示客户端发送的 HTTP 版本，客户端响应时表示连接到的服务器的 HTTP 版本")]),e._v(" "),v("li",[v("code",[e._v("message.method")]),e._v("：请求方法，仅对从 "),v("code",[e._v("http.Server")]),e._v(" 获取的请求有效")]),e._v(" "),v("li",[v("code",[e._v("message.rawHeaders")]),e._v("：原始请求头/响应头的列表，与接收到的完全一致(键和值位于同一列表中，消息头名称不区分大小写的，并且不会合并重复项)")]),e._v(" "),v("li",[v("code",[e._v("message.rawTrailers")]),e._v("：原始的请求/响应的尾部消息头的键和值，与接收到的完全一致")]),e._v(" "),v("li",[v("code",[e._v("message.socket")]),e._v("：与连接关联的 net.Socket 对象")]),e._v(" "),v("li",[v("code",[e._v("message.trailers")]),e._v("：请求/响应的尾部消息头对象")]),e._v(" "),v("li",[v("code",[e._v("message.statusCode")]),e._v("：状态码，仅对从 "),v("code",[e._v("http.ClientRequest")]),e._v(" 获取的响应有效")]),e._v(" "),v("li",[v("code",[e._v("message.statusMessage")]),e._v("：状态信息，仅对从 "),v("code",[e._v("http.ClientRequest")]),e._v(" 获取的响应有效")]),e._v(" "),v("li",[v("code",[e._v("message.url")]),e._v("：请求的 URL 字符串，仅对从 "),v("code",[e._v("http.ClientRequest")]),e._v(" 获取的响应有效")])]),e._v(" "),v("h3",{attrs:{id:"方法-6"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#方法-6"}},[e._v("#")]),e._v(" 方法")]),e._v(" "),v("ul",[v("li",[v("code",[e._v("message.destroy([error])")]),e._v("：")]),e._v(" "),v("li",[v("code",[e._v("message.setTimeout(msecs[, callback])")]),e._v("：")])])])}),[],!1,null,null,null);t.default=s.exports}}]);