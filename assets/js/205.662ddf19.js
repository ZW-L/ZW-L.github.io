(window.webpackJsonp=window.webpackJsonp||[]).push([[205],{619:function(v,_,e){"use strict";e.r(_);var t=e(25),i=Object(t.a)({},(function(){var v=this,_=v.$createElement,e=v._self._c||_;return e("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[e("h2",{attrs:{id:"git-和-svn-的区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#git-和-svn-的区别"}},[v._v("#")]),v._v(" Git 和 SVN 的区别")]),v._v(" "),e("ul",[e("li",[e("code",[v._v("Git")]),v._v(" 是分布式的， "),e("code",[v._v("SVN")]),v._v(" 不是")]),v._v(" "),e("li",[e("code",[v._v("Git")]),v._v(" 把内容按元数据方式存储，而 "),e("code",[v._v("SVN")]),v._v(" 是按文件进行存储")]),v._v(" "),e("li",[e("code",[v._v("Git")]),v._v(" 的分支和 "),e("code",[v._v("SVN")]),v._v(" 的分支不同")]),v._v(" "),e("li",[e("code",[v._v("Git")]),v._v(" 没有一个全局的版本号，而 "),e("code",[v._v("SVN")]),v._v(" 有")]),v._v(" "),e("li",[e("code",[v._v("Git")]),v._v(" 内容完整性要优于 "),e("code",[v._v("SVN")]),v._v("，"),e("code",[v._v("Git")]),v._v(" 的内容存储使用的是 "),e("code",[v._v("SHA-1")]),v._v(" 算法，确保代码内容的完整性")])]),v._v(" "),e("h2",{attrs:{id:"理解-git-的核心原理、工作流程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#理解-git-的核心原理、工作流程"}},[v._v("#")]),v._v(" 理解 Git 的核心原理、工作流程")]),v._v(" "),e("h2",{attrs:{id:"常用的-git-命令"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#常用的-git-命令"}},[v._v("#")]),v._v(" 常用的 Git 命令")]),v._v(" "),e("ul",[e("li",[v._v("配置："),e("code",[v._v("git config")])]),v._v(" "),e("li",[v._v("初始化："),e("code",[v._v("git init")])]),v._v(" "),e("li",[v._v("查看状态："),e("code",[v._v("git status")]),v._v(", "),e("code",[v._v("git diff")])]),v._v(" "),e("li",[v._v("文件操作："),e("code",[v._v("git add")]),v._v(", "),e("code",[v._v("git rm")]),v._v(", "),e("code",[v._v("git mv")])]),v._v(" "),e("li",[v._v("提交修改："),e("code",[v._v("git commit")])]),v._v(" "),e("li",[v._v("撤销操作："),e("code",[v._v("git reset")]),v._v(", "),e("code",[v._v("git revert")])]),v._v(" "),e("li",[v._v("查看历史："),e("code",[v._v("git log")]),v._v(", "),e("code",[v._v("git reflog")])]),v._v(" "),e("li",[v._v("远程仓库："),e("code",[v._v("git clone")]),v._v(", "),e("code",[v._v("git push")]),v._v(", "),e("code",[v._v("git remote")]),v._v(", "),e("code",[v._v("git fetch")]),v._v(", "),e("code",[v._v("git pull")])]),v._v(" "),e("li",[v._v("仓库管理："),e("code",[v._v("git stash")])]),v._v(" "),e("li",[v._v("分支管理："),e("code",[v._v("git branch")]),v._v(", "),e("code",[v._v("git checkout")]),v._v(", "),e("code",[v._v("git merge")]),v._v(", "),e("code",[v._v("git rebase")]),v._v(", "),e("code",[v._v("git cherry-pick")])]),v._v(" "),e("li",[v._v("标签管理："),e("code",[v._v("git tag")]),v._v(", "),e("code",[v._v("git show")])])]),v._v(" "),e("h2",{attrs:{id:"git-merge-和-git-rebase-的区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#git-merge-和-git-rebase-的区别"}},[v._v("#")]),v._v(" git merge 和 git rebase 的区别")]),v._v(" "),e("p",[e("strong",[v._v("使用方式：")]),v._v(" (假设都是将分支 "),e("code",[v._v("dev")]),v._v(" 合并至 "),e("code",[v._v("master")]),v._v(")")]),v._v(" "),e("ul",[e("li",[e("code",[v._v("git merge")]),v._v("：当 "),e("code",[v._v("master")]),v._v(" 分支位于 "),e("code",[v._v("dev")]),v._v(" 分支的直接上游时，"),e("code",[v._v("merge")]),v._v(" 命令只是将 "),e("code",[v._v("master")]),v._v(" 分支指针直接右移；当 "),e("code",[v._v("dev")]),v._v(" 分支是从 "),e("code",[v._v("master")]),v._v(" 分支更早的地方开始时，"),e("code",[v._v("merge")]),v._v(" 命令会采取三方("),e("code",[v._v("dev")]),v._v(" 分支的末端、"),e("code",[v._v("master")]),v._v(" 分支末端、两个分支的公共祖先)合并，最终创建一个有两个祖先的提交历史")]),v._v(" "),e("li",[e("code",[v._v("git rebase")]),v._v("：回到两个分支的公共祖先，将 "),e("code",[v._v("dev")]),v._v(" 分支的提交历史生成一系列文件补丁，附加到 "),e("code",[v._v("master")]),v._v(" 分支末端，最后再手动在 "),e("code",[v._v("master")]),v._v(" 分支上进行 "),e("code",[v._v("merge")]),v._v(" 操作")])]),v._v(" "),e("p",[e("strong",[v._v("区别：")])]),v._v(" "),e("ul",[e("li",[e("code",[v._v("git rebase")]),v._v(" 使提交树更清晰，而 "),e("code",[v._v("git merge")]),v._v(" 会创建一些包含两个祖先的提交历史")]),v._v(" "),e("li",[e("code",[v._v("git rebase")]),v._v(" 尽量不要用于公共仓库的提交，否则有可能使提交树更混乱(除非团队约定用于清理提交历史)")])]),v._v(" "),e("h2",{attrs:{id:"git-pull-和-git-fetch-的区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#git-pull-和-git-fetch-的区别"}},[v._v("#")]),v._v(" git pull 和 git fetch 的区别")]),v._v(" "),e("ul",[e("li",[e("code",[v._v("git pull")]),v._v(" 和 "),e("code",[v._v("git fetch")]),v._v(" 都用于拉取远程仓库的变更")]),v._v(" "),e("li",[e("code",[v._v("git fetch")]),v._v(" 只是执行拉取命令，并不会合并内容")]),v._v(" "),e("li",[e("code",[v._v("git pull")]),v._v(" 相当于执行 "),e("code",[v._v("git fetch")]),v._v(" 和 "),e("code",[v._v("git merge")]),v._v(" 两个命令")]),v._v(" "),e("li",[v._v("为了避免困惑，通常单独使用 "),e("code",[v._v("git fetch")]),v._v(" 和 "),e("code",[v._v("git merge")]),v._v(" 代替 "),e("code",[v._v("git pull")])])]),v._v(" "),e("h2",{attrs:{id:"线上分支回滚"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#线上分支回滚"}},[v._v("#")]),v._v(" 线上分支回滚")]),v._v(" "),e("p",[e("strong",[v._v("暴力覆盖：")])]),v._v(" "),e("ul",[e("li",[e("code",[v._v("git reset HEAD~1")]),v._v("：将本地分支回滚到上次提交的状态")]),v._v(" "),e("li"),v._v(" "),e("li",[e("code",[v._v("git push -f origin dev")]),v._v("：强制推送到远程 "),e("code",[v._v("dev")]),v._v(" 分支")])]),v._v(" "),e("p",[e("strong",[v._v("先复制分支再回滚：")])]),v._v(" "),e("ul",[e("li",[e("code",[v._v("git branch backup")]),v._v("：备份分支")]),v._v(" "),e("li"),v._v(" "),e("li")]),v._v(" "),e("h2",{attrs:{id:"线上分支错误合并"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#线上分支错误合并"}},[v._v("#")]),v._v(" 线上分支错误合并")]),v._v(" "),e("h2",{attrs:{id:"git-解惑"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#git-解惑"}},[v._v("#")]),v._v(" Git 解惑")]),v._v(" "),e("p",[v._v("记录平时遇到的错误，以及解决方法。")]),v._v(" "),e("p",[e("strong",[v._v("修改本地文件名的大小写，与远程仓库的不一致，提交时报错："),e("code",[v._v("Changes not staged for commit")])])]),v._v(" "),e("ul",[e("li",[v._v("解决方法：将文件从 git 仓库拷贝出来，提交一次；将文件移入仓库，再提交一次。")])])])}),[],!1,null,null,null);_.default=i.exports}}]);