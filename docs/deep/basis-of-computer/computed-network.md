---
sidebarDepth: 2
---

## 通信协议

### 什么是协议

### 每层协议在应用程序中发挥的作用




## HTTP

### HTTP 历史

&emsp;&emsp;`HTTP`(Hyper Text Transfer Protocol，超文本传输协议)，用于传输 `HTML`(Hyper Text Markup Language，超文本标记语言)文档的一种协议。并且是基于 `TCP` 协议实现的。

+ 1990 年，由 Tim Berners-Lee 提出
+ 1990 年，提出 HTTP/0.9，但没有作为正式的标准
+ 1996 年，推出 HTTP/1.0
+ 1997 年，推出 HTTP/1.1 (当前使用广泛的版本)
+ 2015 年，推出 HTTP/2.0

### 常见 HTTP 状态码

**状态码分类：**

状态码|分类|说明
-|-|-
1xx|信息类|请求已接收，正在处理
2xx|响应成功类|请求已接收、处理且响应成功
3xx|页面重定向类|需要其他操作才能完成请求
4xx|客户端错误类|客户端请求出现错误或不符合服务器预期，导致服务端无法处理请求
5xx|服务端错误类|服务端处理请求时出错

**常见状态码：**

状态码|标识|含义
-|-|-
200|OK|服务器成功处理并响应客户端的请求。
204|No Content|服务端成功处理客户端的请求，但是响应主体不返回内容。一般用于删除资源、用户登出等不需要服务端返回信息的请求。
206|Partial Content|客户端指定某资源的某部分，服务端成功处理并返回。一般由客户端指定返回内容的范围，否则服务端会在响应头中告知该部分内容在整个资源中的位置。
301|Moved Permanently|永久性移动，或称重定向。指示资源分配到新的 URL 地址，并返回该 URL 地址供浏览器自动重定向跳转。
302|Found|临时移动。指示资源分配到新的 URL 地址，但建议用户继续保留当前的 URL 访问；与 301 一样都会使浏览器重定向，区别于临时的移动意味着新的 URL 将来还可能会改变。
304|Not Modified|请求访问的资源未被修改，此状态码不返回任何资源。服务端会读取客户端提供的 If-Modified-Since 和 If-Modified-Match 请求头，判断客户端的缓存是否是最新的，若是便返回为 304 响应。
307|Temporary Redirect|与 302 基本相同，也会引起浏览器跳转。区别在与 307 确保请求方法和信息主体不会发生改变，而 302 有些情况下会错误地将请求转为 GET 方法。
400|Bad Request|请求报文存在语法错误，导致服务器无法理解和处理请求。
401|Unauthorized|客户端未通过认证或之前的认证失败了，服务器不予以响应资源。
403|Forbidden|服务器理解了客户端的请求，但是拒绝响应对应的资源。一般是因为客户端没有对应的访问权限。
404|Not Found|服务端找不到对应的资源。一般是请求的 URL 地址错误、请求资源被删除或不存在、服务端拒绝响应但不说明等原因。
500|Internal Server Error|服务端本身发生了内部错误。一般是由于服务器自身的 bug 或临时故障。
502|Bad Gateway|当网关或代理服务器向上游服务器发起请求时，得到无效的响应时。
503|Service Unavailable|服务端暂时处于超负载或正在进行停机维护，现在无法处理请求。一般是暂时的状态，如果能够预计恢复时间，响应头应包含 Retry-After 字段表明服务端延迟的时间。
504|Gateway Timeout|当网关或代理服务器向上游服务器或辅助服务器(DNS)发起请求时，未能及时收到响应。


### HTTP 所有状态码的具体含义



### HTTP 请求报文和响应报文的组成



### HTTP 常见请求头的含义


### HTTP 的状态 & 优缺点

`HTTP` 是无状态的，它对发送过的请求和响应都不做持久化处理：

+ 优点：减轻服务器负担
+ 缺点：不能保存客户端的状态(验证登录等情况时)，但 `HTTP/1.1` 引入了 `Cookie` 技术来缓存状态


### HTTP 请求方式和区别

+ GET：用于获取资源
+ POST：用于将主体(表单等)提交到指定无夫区
+ HEAD：用于获取响应头部
+ PUT：用于将请求内容替换为指定内容
+ DELETE：删除指定支援
+ PATCH：对资源进行部分修改


### HTTP 请求优化

+ 减少请求/连接
  + 减少请求：优化数据请求，合并请求等
  + 减少连接：保持一定的连接时间，而不是经历多次的 "三次握手"
+ 缓存数据
  + 客户端缓存在 localeStorage 中
  + 服务端缓存静态资源在 CDN 服务器上
+ 减少传输数据量：对文件进行压缩
+ 优化网络链路
  + 减少域名：减少三级或更高级域名的使用，减少域名解析的时间
  + 使用 CDN


### HTTP 的缺点

+ 通信使用明文：HTTP 协议本身不具有加密功能，无法对通信整体进行加密，所以采用明文方式发送
+ 不验证通信方身份：HTTP 协议不具有判断对方身份的机制，容易造成很多安全问题：
  + 客户端无法确认请求发送的服务器是否是目标服务器，有可能是已伪装的 Web 服务器
  + 服务端无法确认接收响应的客户端是否是目标客户端，有可能是已伪装的 Web 客户端
  + 即使是无意义的请求，服务器也会收到，例如 DDOS(Distributed denial of service，拒绝服务)攻击
+ 无法证明报文的完整性：如果中间方篡改了信息，通信双方都没有方法来确认信息的准确性，容易遭受中间人攻击。但可以通过其他方法，如 `数字签名` ，来保证信息的准确性。


### HTTPS 加密原理

+ `HTTP` 的安全版本，通过 `SSL` 加密


::: tip 术语和技术：
**对称加密 & 非对称加密:**
+ 对称加密：`AES`、`DES` 等，加密解密使用同一个密钥
+ 非对称加密：`RSA` 等，有一对密钥(公钥，私钥)，两个密钥都可以加解密，但用其中一个密钥加密就只有用另一个密钥才能解密

**摘要 & 签名:**
+ 消息摘要：使用哈希函数(MD5, SHA 等)将数据生成唯一的定长的字符串，当数据改变时，使用同一哈希函数生成的摘要信息会不一样，从而验证数据的完整性
+ 签名：为了防止消息摘要在中途被篡改，使用加密算法对消息摘要进行加密，只有拥有密钥才能解密

**SSL 数字证书:**
+ 由 CA(认证中心)机构签发：CA 收到制作证书的请求后，会用非对称加密算法生成公钥和私钥，其中公钥保存在生成的 SSL 证书中，并用 CA 自身的私钥进行签名后，把 SSL 证书和对应的私钥返回给申请者
+ SSL 证书的作用：
  + 身份认证，客户端可以认证服务端的身份
  + 加密传递数据：利用 SSL 证书中的公钥加密数据(该数据应该是随机数生成的对称算法密钥)

**使用两种加密算法的原因:**
+ 单独使用非对称加密算法：这样相当于不加密(因为服务端在之前把公钥返回给浏览器，任何人都可能知道公钥)
+ 单独使用对称加密算法：服务端还要跟浏览器约定唯一密钥，保存密钥等工作
+ 同时使用两者：非对称加密算法用于确保对称加密算法的密钥不被窃取，对称加密算法则用于加密数据；这样服务端就不用保留对称加密的密钥，而是通过公钥解密即可
:::





### HTTPS 通信流程

1. 浏览器将自己支持的加密算法发给服务端
2. 服务端选择其中一组加密算法，将自己的 SSL 证书和公钥返回给浏览器
3. 浏览器验证该证书的合法性
4. 若证书合法(或用户接受了不受信任的证书)，浏览器会生成一串随机数密码，并用公钥进行加密后，发送至服务端
5. 服务端接收浏览器的数据后：
    + 用私钥解密出该随机数密码
    + 用该随机数密码解密握手信息
    + 用该随机数密码加密一段握手信息，发送至浏览器
6. 之后的通信都使用该随机数密码作密钥进行加解密


::: tip 说明：
+ 使用了两种加密算法：对称加密、非对称加密
+ 握手信息和数据是用对称加密的，密钥为浏览器生成的随机数密码
+ 该随机数密码是用非对称加密的，公钥一开始和 SSL 证书一并发送给浏览器，服务端保存私钥
:::


### 开启 HTTPS



### 劫持 HTTPS 请求




### HTTP 1.1 和 HTTP 2.0 带来的改变




### HTTP 1.0/1.1/2.0 的区别

**HTTP 1.0/1.1**
+ 长连接：`HTTP1.0` 需要使用 `keep-alive` 参数来告知服务器建立一个长连接，而 `HTP1.1` 默认支持长连接
+ 节约宽带：`HTTP1.1` 支持只发送一个 `header` 信息（不带任何 `body` 信息）
+ `host` 域：（设置虚拟站点，`web server` 上的多个虚拟站点可以共享同一个 `ip` 端口），`HTTP1.0` 没有 `host` 域

**HTTP 2.0：**

+ 多路复用：`HTTP/1.1` 为了避免浏览器过度消耗服务器资源，限制了浏览器对同一域名的并发请求数量；而 `HTTP/2.0` 不会
+ 数据压缩：启用了强制性的压缩算法来压缩报文
+ 支持 `TLS`：允许使用 `TLS1.2` 或更新版本的协议进行加密，使通信更加安全
+ 应用层协议协商
+ 服务端推送：服务端可以自行判断客户端的请求，选择返回比当前请求更多的数据
+ 流控制：阻止发送方发送过量的数据，以免超出接收方的处理能力





## TCP

### TCP/IP 网络协议族的组成

### 有哪些协议是可靠的，TCP 协议怎样保证可靠支付

### 三次握手 & 四次握手 & 为什么要使用这些机制

**三次握手：**

1. 客户端发送报文给服务器，请求建立连接
2. 服务器响应报文，回应服务器可以建立连接，并处于等待连接状态
3. 客户端再次发送报文给服务端，完成建立连接

**四次握手：**


**优缺点：**

+ 优点：保证了传输数据过程的稳定性(通过三次握手建立了连接)
+ 缺点：
  + 三次握手消耗时间
  + 服务器保持连接会消耗资源
  + 服务器不能主动给客户端发送信息(一般采取轮询来让客户端定时向服务端发送请求)


## IP







## DNS

### 认识 URL

**URL 地址：**

```
https://www.zwlike.top:3000/blog/index.html?tag=note&limit=10#/main
```

**分析：**

+ 协议：`http`, `https`, `ftp` 等
+ 服务器地址：域名(`www.zwlike.top`)或 `IP` 地址
+ 端口：`3000`，在服务器地址和一个 `:` 标识后的数字(没有则使用默认端口)
+ 请求路径：`/blog/index.html`，指示服务器下的文件相对路径
+ 请求参数：`tag=note&limit=10`，以 `?` 标识开始，且以 `key=value` 形式的单组或多组(用 `&` 分隔)的查询参数
+ 片段标识符：`#/main`，用 `<a>` 标签作锚点的跳转定位页面位置或 HTML5 的单页应用劫持跳转使请求路径和参数发生的变化

::: tip 说明：
+ `HTTP` 默认端口为 `80`，`HTTPS` 默认端口为 `443`
:::


### DNS 介绍 & DNS 解析


### DNS 优化原理






## WebSocket

### 理解 WebSocket 协议

+ `WebSocket` 在 `HTML5` 中引入，与 `HTTP` 协议一样都是建立在 `TCP` 协议之上的应用层协议，都属于可靠协议
+ `WebSocket` 连理连接时需要使用 `HTTP` 协议通信
+ `WebSocket` 只需要完成一次握手就能创建持久性连接(`HTTP` 需要三次握手)；它也是有状态的(`HTTP` 是无状态的)，不用再每次发送报文都提供报文信息
+ `WebSocket` 允许双工通信，不仅客户端能向服务端发送消息，而且服务端也能主动向客户端发送消息


### 浏览器使用

**使用全局构造函数：**

```js
const ws = new WebSocket(url, protocols)
```

**参数：**

+ `url: String`: 请求 url 地址
+ `protocols='': Array`: 单个协议名称或包含多个协议的数组

更多实例属性和方法 [HTML5 WebSocket](/base/html/html5/websocket)

### 服务端使用

**Node.js 中使用第三方模块 `ws`：**

```js
const WebSocket = require('ws')
const http = require('ws')

// 两种方式创建 WebSocket 实例
// 1.传入一个对象
const wsServer = new WebSocket.Server({ port: 1234 })

// 2.传入一个 http 实例
const httpServer = new https.createServer()
const wsServer = new WebSocket.Server({ server: httpServer })
```


### 在客户端和服务端通信

```js
// 客户端
const ws = new WebSocket('ws://localhost:1234')
console.log('Try to connect WebSocket Server...')

ws.addEventListener('open', () => {
  console.log('Connect Success!')
  ws.send('Client: Hi, WebSocket!')
})

ws.addEventListener('message', event => {
  console.log(event.data)
})

// 服务端
const WebSocket = require('ws')
const wss = new WebSocket.Server({ port: 1234 })

wss.on('connection', ws => {
  console.log('Server connection success!')
  ws.on('message', message => {
    console.log('received: %s', message)
    ws.send(message)
    ws.send('Server: Hello, I\'m WebSocket!')
  })
})
```



## CDN

### CDN 的作用和原理

+ CDN：内容分发网络。尽可能的避开互联网有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输的更快更稳定。
+ 原理：广泛采用各种缓存服务器，将这些缓存服务器分布到用户访问相对的地区或者网络中；将用户的访问指向距离最近的缓存服务器，由缓存服务器直接响应用户的请求



## Cookie

&emsp;&emsp;由于 `HTTP` 是无状态的，不能保存客户端的状态(验证登录等情况时)，因此 `HTTP/1.1` 引入了 `Cookie` 技术来缓存状态。


### 分类

+ 持久化 `Cookie`: 保存在硬盘中，由一个过期时间(或被用户手动清理)
+ 非持久化 `Cookie`: 保存在内存中，相当于临时缓存，在浏览器关闭后消失


### 使用

+ 请求报文的 Cookie 字段: cookie
+ 响应报文的 Cookie 字段: set-cookie，可以使用多个该字段，并且可以使用以下几个附加属性(`键=值` 的形式，多个属性间用 `;` 分隔): 
  + `expires`: 指定数据的有效期，若不设置则默认在浏览器关闭后消失；而且当 Cookie 从浏览器发出后就无法直接删除，只能覆盖
  + `path`: 指定 Cookie 发送范围的路径，默认为根路径
  + `domain`: 指定 Cookie 适用的域名，匹配规则为结尾匹配
  + `secure`: 指定 Cookie 只能在 HTTPS 安全连接中使用，不设置时可以在 HTTP/HTTPS 中使用
  + `HttpOnly`: 指定浏览器端的 javascript 脚本无法获取 Cookie 内容(从而无法轻易修改或删除)，常用于防止跨站脚本(XSS)对 Cookie 信息的窃取


### 缺陷

+ 大小是有限的，早期浏览器对 Cookie 的大小限制为 4KB，不同浏览器有所不同 
+ 消耗网络带宽
+ 可以被客户端禁用的
+ 可能会被窃取或篡改


### 对比其他存储

存储方式|说明|容量|特点
-|-|-|-
Cookie|服务端设置，分为持久化 Cookie和非持久化 Cookie|4KB 左右|容量小，可被禁用，可能被窃取或篡改，在同源窗口中共享的
Session Storage|浏览器的全局对象，非持久化存储|5MB|只能存储简单数据(复杂数据只能 json 化)，页面关闭后清除，不同域之间不共享
Locale Storage|浏览器的全局对象，持久化存储|5MB|只能存储简单数据(复杂数据只能 json 化)，不会消失，除非手动清除，在同源窗口中共享的
Indexed DB|浏览器端的非关系型数据库(NoSQL)|---|直接将数据存储在浏览器端的数据库中


### Cookie 与状态

&emsp;&emsp;在 Cookie 的使用场景中，最重要的是授权认证。授权认证的常用方式有两种：基于 Cookie、基于 token，他们的实现有所不同，但步骤大致相同。


**授权认证的步骤：**

1. 登录状态信息的保存：浏览器发送 POST 请求提交登录信息 -> 服务端响应信息、验证通过并返回一个状态值来保存登录状态
2. 登陆状态信息的提取：登录完成后 -> 浏览器发送请求，服务端总能获取浏览器的登录状态，从而正确响应页面


**授权认证的方式：**

+ 基于 Cookie
  1. 服务端收到浏览器请求后，创建一个 session 会话，保存在服务端的内存或数据库中
  2. 接着生成一个随机的、唯一的 id，用来和会话信息进行映射并写入 Cookie，该 Cookie 通常带 HttpOnly 属性
+ 基于 token
  1. 服务端收到浏览器请求后，对用户信息进行编码(生成一串较长的字符串)
  2. 将该字符串作为 token 字段的属性值，返回给浏览器


**两种认证方式的主要区别：**

+ 基于 Cookie：有状态的。获取状态时，服务端要获取请求头部的 Cookie 字段的 session 属性值，再找到之前保存在服务端的会话信息进行校验；这种方式需要客户端和服务端都保存信息。
+ 基于 token：无状态的。获取状态时，直接利用密钥信息对 token 进行解密和校验；这种方式下服务端不用保存信息，能够减轻服务端的压力，也可用于无 Cookie 的情况(微信小程序)。


**基于 token 的优点：**

+ **无状态**: 服务端不用保存状态信息，减轻服务端压力
+ **域无关**: Cookie 与域有关，token 与域无关
+ **性能好**: 请求头部会自动带上 Cookie，占用带宽，而 token 则可以按需添加；另外服务端收到 Cookie 后可能要在数据库中查询认证，而 token 则直接解密认证
+ **通用性强**: 很多设备(或小程序等应用)不支持 Cookie，而且 Cookie 可以被用户禁用，因此 token 通用性更好


**创建 token 的方式：**

使用最多的是 `JSON Web Token`，简称 `JWT`。该方式生成的 token 分为三个部分(通过 `.` 分割)：

+ `Header`: 头部。由算法和 token 类型组成，属性名使用简写: `{ "alg": "HS256", "typ": "JWT" }`
+ `Payload`: 负载。
+ `Signature`: 签名。






## 服务端 API

&emsp;&emsp;服务端 `API`(Application Programming Interface，应用程序编程接口)，在程序内部指的是各个模块、函数、类的调用参数和返回值，在程序外部指不同程序之间的调用参数和返回结果。在 Web 中指的是前后端通信的接口，一般借助 HTTP(S) 协议来实现。

&emsp;&emsp;当前流行的 Web API 设计为 `REST` 和 `GraphQL`。


### REST API

&emsp;&emsp;简称 `REST`(Representation State Transfer，表现层状态转换)，指的是一种设计风格(不是标准)。

**特点：**

+ 所有通信都是无状态的，状态统一由客户端进行维护，减轻了服务端的压力
+ 可以利用缓存来提升通信效率
+ 可结合一些 HTTP 协议的特点：用 URL 的方式指向不同的资源


**定制团队规范：**

+ **请求路径**
  + 所有请求路径对应特点的资源，不要包含动词、形容词等修饰符，必要时应该使用复数
  + 多个单词组合使用 `songList`, `song_list`, `song-list` 三者之一
  + 合适的资源嵌套层级，使用 id 占位符(`:id`)标识资源
  + 用参数对资源进行过滤而不是使用无规则的 URL，参数之间用 `&` 分开，多个参数值用 `,` 分开
+ **请求头部**: 不同的操作使用对应语义的请求方法
  + `GET`: 获取资源，常用于查询
  + `POST`: 创建资源，或数据提交(用户登录等)
  + `PUT`: 修改资源
  + `DELETE`: 删除资源
+ **请求体**: 一般采用 JSON 格式提交数据(文件上传除外)
+ **响应头部**: 遵循 HTTP(S) 规范的状态码和状态信息描述请求结果
+ **响应体**
  + 一般响应为 JSON 格式
  + 响应结果处理: 包括响应描述和响应分页


**工具：**

+ Swagger



### GraphQL

&emsp;&emsp;简称 `GraphQL`(Graph Query Language，图表化查询语言)，由 `Facebook` 推出。


**特点：**

+ 它使用模式(Schema)来描述一类数据的结构，类似 mongoose 的形式
+ 所有请求都使用 POST 方法，同时将 Schema 作为请求参数放入请求体中


**设计：**

+ **类型**: 返回后端定义的类型
+ **验证**: 后端对于不符合要求的 GraphQL 请求会给出明确的错误提示
+ **内省**: 告诉调用者当前服务器指出哪些查询
+ **查询与变更**: 查询操作以 `query` 开头，变更操作以 `mutation` 开头


**工具：**

+ GraphiQL
+ GraphQL Voyager