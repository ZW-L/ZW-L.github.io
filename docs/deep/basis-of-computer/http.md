## HTTP 协议简介

### HTTP 历史

&emsp;&emsp;`HTTP` (Hyper Text Transfer Protocol，超文本传输协议)，用于传输 `HTML` (Hyper Text Markup Language，超文本标记语言) 文档的一种协议。**并且是基于 `TCP` 协议实现的。**

+ 1890 年，由 蒂姆·贝纳斯·李（Tim Berners—Lee）提出
+ 1990 年，提出 HTTP/0.9，但没有作为正式的标准
+ 1996 年，推出 HTTP/1.0
+ 1997 年，推出 HTTP/1.1 (当前使用广泛的版本)
+ 2015 年，推出 HTTP/2.0

### HTTP 的通信方式

(1) **`HTTP` 协议为客户端(发起请求)和服务端(响应请求)服务的：**

+ 客户端：Web 开发中，即浏览器；其他环境中，为各类 app 或应用程序等；甚至是一个代理服务器
+ 服务端：与客户端对应，能够返回客户端所需数据的服务器程序、云服务器等

(2) **由于 `TCP` 协议是面向连接的，因此基于 `TCP` 协议实现的 `HTTP` 协议也需要建立连接(客户端和服务器)。最常见的 `三次握手` ：**

1. 客户端发送报文给服务器，请求建立连接
2. 服务器响应报文，回应服务器可以建立连接，并处于等待连接状态
3. 客户端再次发送报文给服务端，完成建立连接

&emsp;&emsp;这是一个成功建立的连接，当然也有其他原因阻断连接：如服务端拒绝响应，客户端请求出错等。

(3) **`HTTP` 通信的优缺点:**

+ 优点：保证了传输数据过程的稳定性(通过三次握手建立了连接)
+ 缺点：
  + 三次握手消耗时间
  + 服务器保持连接会消耗资源
  + 服务器不能主动给客户端发送信息(一般采取轮询来让客户端定时向服务端发送请求)

### HTTP 的状态

&emsp;&emsp;`HTTP` 是无状态协议，它对发送过的请求和响应都不做持久化处理。

+ 优点：减轻服务器负担
+ 缺点：不能保存客户端的状态(验证登录等情况时)，但 HTTP/1.1 引入了 Cookie 技术来缓存状态




## HTTP 协议内容

### 请求行/状态行

(1) **URL**

一个完整的 URL 地址如下：
```
https://www.zwlike.top:3000/blog/index.html?tag=note&limit=10#/main/
```
它包括了以下几个部分：
+ 协议：`http`, `https`, `ftp` 等
+ 服务器地址：域名(`www.zwlike.top`)或 `IP` 地址
+ 端口：在服务器地址和一个 `:` 标识后的数字(否则使用默认端口)，这里为 `3000`；此外 `HTTP` 默认端口为 `80`，`HTTPS` 默认端口为 `443`
+ 请求路径：指示服务器下的文件相对路径，这里为 `/blog/index.html`
+ 请求参数：紧跟请求路径后，以 `?` 标识开始，且以 `key=value` 形式的单组或多组(用 `&` 分隔)的查询参数；但只能传递简单的参数，而且是明文传递(不适合传输敏感数据)
+ 片段标识符：用于定位页面位置(用 `<a>` 标签作锚点的跳转)，或 HTML5 后单页应用的劫持跳转使请求路径和参数发生的变化


(2) **请求方法**

+ GET：用于获取资源
+ POST：用于将主体(表单等)提交到指定无夫区
+ HEAD：用于获取响应头部
+ PUT：用于将请求内容替换为指定内容
+ DELETE：删除指定支援
+ PATCH：对资源进行部分修改

(3) **状态码/状态信息**

+ 状态码分类：

分类|分类含义|含义
-|-|-
1xx|标识信息|请求已接收，正在处理
2xx|标识成功|请求已接收、处理且响应成功
3xx|标识重定向|需要其他操作才能完成请求
4xx|标识客户端错误|客户端请求出现错误或不符合服务器预期，导致服务端无法处理请求
5xx|标识服务端错误|服务端处理请求时出错


+ 常见状态码：

状态码|标识|含义
-|-|-
200|OK|服务器成功处理并响应客户端的请求。
204|No Content|服务端成功处理客户端的请求，但是响应主体不返回内容。一般用于删除资源、用户登出等不需要服务端返回信息的请求。
206|Partial Content|客户端指定某资源的某部分，服务端成功处理并返回。一般由客户端指定返回内容的范围，否则服务端会在响应头中告知该部分内容在整个资源中的位置。
301|Moved Permanently|永久性移动，或称重定向。指示资源分配到新的 URL 地址，并返回该 URL 地址供浏览器自动重定向跳转。
302|Found|临时移动。指示资源分配到新的 URL 地址，但建议用户继续保留当前的 URL 访问；与 301 一样都会使浏览器重定向，区别于临时的移动意味着新的 URL 将来还可能会改变。
304|Not Modified|请求访问的资源未被修改，此状态码不返回任何资源。服务端会读取客户端提供的 If-Modified-Since 和 If-Modified-Match 请求头，判断客户端的缓存是否是最新的，若是便返回为 304 响应。
307|Temporary Redirect|与 302 基本相同，也会引起浏览器跳转。区别在与 307 确保请求方法和信息主体不会发生改变，而 302 有些情况下会错误地将请求转为 GET 方法。
400|Bad Request|请求报文存在语法错误，导致服务器无法理解和处理请求。
401|Unauthorized|客户端未通过认证或之前的认证失败了，服务器不予以响应资源。
403|Forbidden|服务器理解了客户端的请求，但是拒绝响应对应的资源。一般是因为客户端没有对应的访问权限。
404|Not Found|服务端找不到对应的资源。一般是请求的 URL 地址错误、请求资源被删除或不存在、服务端拒绝响应但不说明等原因。
500|Internal Server Error|服务端本身发生了内部错误。一般是由于服务器自身的 bug 或临时故障。
502|Bad Gateway|当网关或代理服务器向上游服务器发起请求时，得到无效的响应时。
503|Service Unavailable|服务端暂时处于超负载或正在进行停机维护，现在无法处理请求。一般是暂时的状态，如果能够预计恢复时间，响应头应包含 Retry-After 字段表明服务端延迟的时间。
504|Gateway Timeout|当网关或代理服务器向上游服务器或辅助服务器(DNS)发起请求时，未能及时收到响应。



### 头部

&emsp;&emsp;重要(常见)的头部字段：

(1) **通用头部字段**

+ Cache-Control：控制缓存，在不同头部中可使用的值不大一样
  + 共用值
    + no-cache：强制使用最新的值，而不是缓存的值
    + no-store：报文中包含机密信息，不应该被缓存
    + no-transform：缓存不能改变主体的媒体类型，能防止缓存服务器压缩图片等操作
    + max-age：缓存有效期，单位为秒
  + 请求头部常用值
    + min-fresh：要求缓存在指定时间(单位为秒)内返回响应
    + only-if-cached：客户端仅需要缓存服务器缓存的资源，即缓存服务器不会向源服务器转发请求
  + 响应头部常用值 
    + must-revalidate：在本地缓存过期前可以使用，否则必须进行有效性验证
    + public：响应可以被任何对象缓存
    + private：响应只能被特定用户缓存
    + proxy-revalidate：仅适用于共享(public)缓存，私有缓存时忽略
+ Connection
  + Close：关闭此次连接
  + Keep-Alive：HTTP/1.1 默认值。保持持久的连接，下次发送消息时不需要再次建立连接
+ Date：报文创建的时间日期

(2) **请求头部字段**

+ accept：客户端能够支持的内容类型，均为 [MIME 类型/MIME 子类型]()，举例：
  + text/html：HTML 文档
  + application/xhtml_xml：XHTML 文档
  + image/webp：图片文件
  + application/xml;q=0.9：XML 文档，`q` 指示权重
  + \*/\*;q=0.8：通配符 `*`，指示 `任意 MIME 类型/任意 MIME 子类型`
+ accept-charset：客户端可以处理的字符集类型，通常不用设置(文本类型有默认的字符集类型)
+ accept-encoding：客户端能够接收的编码方式，通常为某些压缩算法(gzip、compress 等)
+ accept-language：客户端支持的语言类型
+ authorization：告知服务端验证信息；通常在收到 401 请求后添加该字段，值为 `type credentials`
+ host：唯一必须传递的值。要请求的服务器的网址，包括端口号(否则使用默认端口)
+ if-modified-since：通常为日期，确认代理或客户端本地资源的有效性。服务端会根据该值对比资源更新的时间，判断返回最新的资源还是返回 304 响应
+ if-none-match：类似 if-modified-since，用于判断本地缓存是否有效；通常存储为上一次响应头部的 ETag 值，若该值与请求资源的 ETag 值不一致时，服务器才会处理请求

(3) **响应头部字段**

+ age：告知客户端，服务端在多久前(单位为秒)创建了响应；若是缓存服务器创建的，则指的是缓存后的响应再次发起认证到认证完成的时间；代理创建的响应必须包含 age 字段
+ ETag：服务端每次更新资源后生成对资源唯一的标识，其生成算法由服务端指定；还细分为两种：
  + 强 ETag：只要资源发生变化就改变值，格式："asdfc12321"
  + 弱 ETag：只有资源发生较大改变时才改变值，格式：W/"asdfc12321"
+ location：引导客户端至某个与请求 URL 位置不同的资源，一般配合 302 等 3xx 形式的重定向类状态码使用
+ www-authenticate：告知客户端，服务端可接受的认证方案

(4) **主体头部字段**

&emsp;&emsp;主体头部字段包含于请求报文或响应报文的主体部分的头部，用于补充和主体相关的信息。

+ allow：告知客户端，服务端能够支持的 HTTP 请求方法
+ content-encoding；告知客户端，服务端当前响应内容的编码方式(主要为 `gzip`, `compress`, `deflate`, `identity`)
+ content-length：主体部分的大小，单位为字节
+ content-type：对应请求头部的 accept 字段，表明响应主体的 MIME 类型
+ last-modified：资源的最后修改时间，配合缓存使用
+ expires：表示失效日期；若缓存服务器接收到含该字段的响应，会在失效日期前以缓存应答请求，失效后会重新向源服务器发起请求

(5) **其他头部字段**

&emsp;&emsp;HTTP 的头部信息是可以自定义的，服务端和客户端都可以根据需要进行扩展。

+ X-Frame-Options：常用作响应头部字段，表示网站内容是否允许被嵌入其他网站的 iframe 中(值为 `deny` 为禁止，能有效防止常见的点击劫持)

### 主体

&emsp;&emsp;主体部分指的是请求体和响应体。当前广泛使用的 `REST API` 设计规范的四种请求方法：GET, POST, PUT, DELETE 中，GET 请求没有请求主体，常用的 POST 请求主体头部字段：

+ application/json：最常用。表示请求主体为序列化后的 JSON 格式的数据
+ text/xml：表示请求主体为 XML 格式的数据
+ multipart/form-data：from 表单的默认头部字段，常用于上传文件
+ application/x-www-from-urlencoded：form 表单结构，用于传递字符串参数的键值对，与 URL 参数格式类似


### Cookie

&emsp;&emsp;由于 `HTTP` 是无状态的，不能保存客户端的状态(验证登录等情况时)，因此 `HTTP/1.1` 引入了 `Cookie` 技术来缓存状态。

(1) **Cookie 分类**

+ 持久化 Cookie：保存在硬盘中，由一个过期时间(或被用户手动清理)
+ 非持久化 Cookie：保存在内存中，相当于临时缓存，在浏览器关闭后消失

(2) **Cookie 使用**

+ 请求报文的 Cookie 字段：cookie
+ 响应报文的 Cookie 字段：set-cookie，可以使用多个该字段，并且可以使用以下几个附加属性(`键=值` 的形式，多个属性间用 `;` 分隔)：
  + expires：指定数据的有效期，若不设置则默认在浏览器关闭后消失；而且当 Cookie 从浏览器发出后就无法直接删除，只能覆盖
  + path：指定 Cookie 发送范围的路径，默认为根路径
  + domain：指定 Cookie 适用的域名，匹配规则为结尾匹配
  + secure：指定 Cookie 只能在 HTTPS 安全连接中使用，不设置时可以在 HTTP/HTTPS 中使用
  + HttpOnly：指定浏览器端的 javascript 脚本无法获取 Cookie 内容(从而无法轻易修改或删除)，常用于防止跨站脚本(XSS)对 Cookie 信息的窃取

(3) **Cookie 缺陷**

+ Cookie 的大小是有限的，早期浏览器对 Cookie 的大小限制为 4KB，不同浏览器有所不同 
+ Cookie 会消耗网络带宽
+ Cookie 是可以被客户端禁用的
+ Cookie 可能会被窃取或篡改

(4) **Cookie 对比其他存储**

存储方式|说明|容量|特点
-|-|-|-
Cookie|服务端设置，分为持久化 Cookie和非持久化 Cookie|4KB 左右|容量小，可被禁用，可能被窃取或篡改，在同源窗口中共享的
Session Storage|浏览器的全局对象，非持久化存储|5MB|只能存储简单数据(复杂数据只能 json 化)，页面关闭后清除，不同域之间不共享
Locale Storage|浏览器的全局对象，持久化存储|5MB|只能存储简单数据(复杂数据只能 json 化)，不会消失，除非手动清除，在同源窗口中共享的
Web SQL|浏览器端的关系型数据库|---|直接将数据存储在浏览器端的数据库中
Indexed DB|浏览器端的非关系型数据库(NoSQL)|---|直接将数据存储在浏览器端的数据库中

(5) **Cookie 与状态**

&emsp;&emsp;在 Cookie 的使用场景中，最重要的是授权认证。授权认证的常用方式有两种：基于 Cookie、基于 token，他们的实现有所不同，但步骤大致相同。

**授权认证的步骤：**

1. 登录状态信息的保存：浏览器发送 POST 请求提交登录信息 -> 服务端响应信息、验证通过并返回一个状态值来保存登录状态
2. 登陆状态信息的提取：登录完成后 -> 浏览器发送请求，服务端总能获取浏览器的登录状态，从而正确响应页面

**授权认证的方式：**

+ 基于 Cookie
  1. 服务端收到浏览器请求后，创建一个 session 会话，保存在服务端的内存或数据库中
  2. 接着生成一个随机的、唯一的 id，用来和会话信息进行映射并写入 Cookie，该 Cookie 通常带 HttpOnly 属性
+ 基于 token
  1. 服务端收到浏览器请求后，对用户信息进行编码(生成一串较长的字符串)
  2. 将该字符串作为 token 字段的属性值，返回给浏览器

**两种认证方式的主要区别：**

+ 基于 Cookie：有状态的。获取状态时，服务端要获取请求头部的 Cookie 字段的 session 属性值，再找到之前保存在服务端的会话信息进行校验；这种方式需要客户端和服务端都保存信息。
+ 基于 token：无状态的。获取状态时，直接利用密钥信息对 token 进行解密和校验；这种方式下服务端不用保存信息，能够减轻服务端的压力，也可用于无 Cookie 的情况(微信小程序)。

**基于 token 的方式更好：**

1. 无状态：服务端不用保存状态信息，减轻服务端压力
2. 域问题：Cookie 与域有关，token 与域无关
3. 性能问题：请求头部会自动带上 Cookie，占用带宽，而 token 则可以按需添加；另外服务端收到 Cookie 后可能要在数据库中查询认证，而 token 则直接解密认证
4. 通用性：很多设备(或小程序等应用)不支持 Cookie，而且 Cookie 可以被用户禁用，因此 token 通用性更好

**创建 token 的方式：**

&emsp;&emsp;使用最多的是 `JSON Web Token`，简称 `JWT`。该方式生成的 token 分为三个部分(通过 `.` 分割)：

+ Header：头部。由算法和 token 类型组成，属性名使用简写：`{ "alg": "HS256", "typ": "JWT" }`
+ Payload：负载。
+ Signature：签名。






## HTTP 请求优化

+ 减少请求/连接
  + 减少请求：优化数据请求，合并请求等
  + 减少连接：保持一定的连接时间，而不是经历多次的 "三次握手"
+ 缓存数据
  + 客户端缓存在 Locale Storage 中
  + 服务端缓存静态资源在 CDN 服务器上
+ 减少传输数据量：对文件进行压缩
+ 优化网络链路
  + 减少域名：减少三级或更高级域名的使用，减少域名解析的时间
  + 使用 CDN(Content Delivery Network)



## HTTP/2 协议

+ 多路复用：HTTP/1.1 为了避免浏览器过度消耗服务器资源，限制了浏览器对同一域名的并发请求数量；而 HTTP/2.0 不会
+ 压缩：启用了强制性的压缩算法来压缩报文
+ 支持 TLS：允许使用 TLS 1.2 或更新版本的协议进行加密，使通信更加安全
+ 应用层协议协商
+ 服务端推送：服务端可以自行判断客户端的请求，选择返回比当前请求更多的数据
+ 流控制：阻止发送方发送过量的数据，以免超出接收方的处理能力





## HTTPS 协议

### HTTP 的缺点

+ 通信使用明文：HTTP 协议本身不具有加密功能，无法对通信整体进行加密，所以采用明文方式发送
+ 不验证通信方身份：HTTP 协议不具有判断对方身份的机制，容易造成很多安全问题：
  + 客户端无法确认请求发送的服务器是否是目标服务器，有可能是已伪装的 Web 服务器
  + 服务端无法确认接收响应的客户端是否是目标客户端，有可能是已伪装的 Web 客户端
  + 即使是无意义的请求，服务器也会收到，例如 DDOS(Distributed denial of service，拒绝服务)攻击
+ 无法证明报文的完整性：如果中间方篡改了信息，通信双方都没有方法来确认信息的准确性，容易遭受中间人攻击。但可以通过其他方法，如 `数字签名` ，来保证信息的准确性。

### HTTPS 的理解

(1) **HTTPS 的通信流程**

1. 浏览器将自己支持的加密算法发给服务端
2. 服务端选择其中一组加密算法，将自己的 SSL 证书和公钥返回给浏览器
3. 浏览器验证该证书的合法性
4. 若证书合法(或用户接受了不受信任的证书)，浏览器会生成一串随机数密码，并用公钥进行加密后，发送至服务端
5. 服务端接收浏览器的数据后：
  + 用私钥解密出该随机数密码
  + 用该随机数密码解密握手信息
  + 用该随机数密码加密一段握手信息，发送至浏览器
6. 之后的通信都使用该随机数密码作密钥进行加解密

注意：
  + 使用了两种加密算法：对称加密、非对称加密
  + 握手信息和数据是用对称加密的，密钥为浏览器生成的随机数密码
  + 该随机数密码是用非对称加密的，公钥一开始和 SSL 证书一并发送给浏览器，服务端保存私钥

(2) **对称加密和非对称加密**

+ 对称加密：`AES`、`DES` 等，加密解密使用同一个密钥
+ 非对称加密：`RSA` 等，有一对密钥(公钥，私钥)，两个密钥都可以加解密，但用其中一个密钥加密就只有用另一个密钥才能解密

(3) **摘要和签名**

+ 消息摘要：使用哈希函数(MD5, SHA 等)将数据生成唯一的定长的字符串，当数据改变时，使用同一哈希函数生成的摘要信息会不一样，从而验证数据的完整性
+ 签名：为了防止消息摘要在中途被篡改，使用加密算法对消息摘要进行加密，只有拥有密钥才能解密

(4) **SSL 数字证书**

+ 由 CA(认证中心)机构签发：CA 收到制作证书的请求后，会用非对称加密算法生成公钥和私钥，其中公钥保存在生成的 SSL 证书中，并用 CA 自身的私钥进行签名后，把 SSL 证书和对应的私钥返回给申请者
+ SSL 证书的作用：
  + 身份认证，客户端可以认证服务端的身份
  + 加密传递数据：利用 SSL 证书中的公钥加密数据(该数据应该是随机数生成的对称算法密钥)

(5) **为什么要使用两种加密算法**

+ 单独使用非对称加密算法：这样相当于不加密(因为服务端在之前把公钥返回给浏览器，任何人都可能知道公钥)
+ 单独使用对称加密算法：服务端还要跟浏览器约定唯一密钥，保存密钥等工作
+ 同时使用两者：非对称加密算法用于确保对称加密算法的密钥不被窃取，对称加密算法则用于加密数据；这样服务端就不用保留对称加密的密钥，而是通过公钥解密即可





## WebSocket 协议

### 简介

+ WebSocket 在 HTML5 中引入，与 HTTP 协议一样都是建立在 TCP 协议之上的应用层协议，都属于可靠协议
+ WebSocket 连理连接时需要使用 HTTP 协议通信
+ WebSocket 只需要完成一次握手就能创建持久性连接(HTTP 需要三次握手)；它也是有状态的(HTTP 是无状态的)，不用再每次发送报文都提供报文信息
+ WebSocket 允许双工通信，不仅客户端能向服务端发送消息，而且服务端也能主动向客户端发送消息

### 使用

(1) **客户端使用**

使用浏览器提供的全局构造函数：
```js
new WebSocket(url, protocols)
// url: 必须。请求 url 地址
// protocols: 可选，默认为 ''。为单个协议名称或包含多个协议的数组
```

**实例的常用属性：**

属性名|类型|描述
-|-|-
binaryType|String|默认为 'blob'，传输的二进制内容类型
bufferedAmount|Number|只读。等待发送队列中的字节数，发送后重置为0
extensions|String|服务器选定的扩展，不常用
protocol|String|对应创建实例的 protocols 参数
readyState|Number|只读。指示当前连接的状态，值为对应的常量：<br>WebSocket.CONNECTING - 0，连接未开启<br>WebSocket.OPEN - 1，连接已开始并准备通信<br>WebSocket.CLOSING - 2，连接正在关闭<br>WebSocket.CLOSED - 3，连接关闭或无法建立连接
url|String|只读。对应创建实例的 url 参数

**实例支持的函数：**

函数名|描述
-|-
open|监听连接开启事件，当 readyState 的值变为 OPEN 时触发。触发时表明连接建立完成并准备好发送和接收数据
message|监听消息接收事件，当收到服务端消息时触发
close|监听连接关闭事件，当 readyState 的值变为 CLOSED 时触发
error|监听错误发生事件
send|向服务端发送数据
close|主动关闭连接


(2) **服务端使用**

**Node.js 使用第三方模块 `ws`：**

```js
const WebSocket = require('ws');
const http = require('ws');

// 两种方式创建 WebSocket 实例
// 1.传入一个对象
const wsServer = new WebSocket.Server({ port: 1234 });

// 2.或传入一个 http 实例
const httpServer = new https.createServer();
const wsServer = new WebSocket.Server({ server: httpServer });
```

**Demo:**
```js
// 客户端
const ws = new WebSocket('ws://localhost:1234');
console.log('Try to connect WebSocket Server...');
ws.addEventListener('open', () => {
  console.log('Connect Success!');
  ws.send('Client: Hi, WebSocket!');
});

ws.addEventListener('message', event => {
  console.log(event.data);
});

// 服务端
const WebSocket = require('ws');

const wss = new WebSocket.Server({ port: 1234 });
wss.on('connection', ws => {
  console.log('Server connection success!')
  ws.on('message', message => {
    console.log('received: %s', message);
    ws.send(message);
    ws.send('Server: Hello, I\'m WebSocket!');
  });
});

```




## 服务端 API

&emsp;&emsp;`API`(Application Programming Interface，应用程序编程接口)，在程序内部指的是各个模块、函数、类的调用参数和返回值，在程序外部指不同程序之间的调用参数和返回结果。在 Web 中指的是前后端通信的接口，一般借助 HTTP(S) 协议来实现。
&emsp;&emsp;当前流行的 Web API 设计为 `REST` 和 `GraphQL`。

### REST API

&emsp;&emsp;`REST`(Representation State Transfer，表现层状态转换)，指一种设计风格(不是标准)：

+ 所有通信都是无状态的，状态统一由客户端进行维护，减轻了服务端的压力
+ 可以利用缓存来提升通信效率
+ 可结合一些 HTTP 协议的特点：用 URL 的方式指向不同的资源


**一个团队规范的例子：**

1. 请求路径
  + 所有请求路径对应特点的资源，不要包含动词、形容词等修饰符，必要时应该使用复数
  + 多个单词组合使用 `songList`, `song_list`, `song-list` 三者之一
  + 合适的资源嵌套层级，使用 id 占位符(`:id`)标识资源
  + 用参数对资源进行过滤而不是使用无规则的 URL，参数之间用 `&` 分开，多个参数值用 `,` 分开
2. 请求头部：不同的操作使用对应语义的请求方法
  + GET：获取资源，常用于查询
  + POST：创建资源，或数据提交(用户登录等)
  + PUT：修改资源
  + DELETE：删除资源
3. 请求体：一般采用 JSON 格式提交数据(文件上传除外)
4. 响应头部：遵循 HTTP(S) 规范的状态码和状态信息描述请求结果
5. 响应体
  + 一般响应为 JSON 格式
  + 响应结果处理：包括响应描述和响应分页


**REST API 工具：**

+ Swagger


### GraphQL

&emsp;&emsp;`GraphQL`(Graph Query Language，图表化查询语言)，由 `Facebook` 推出。

**特点：**

+ 它使用模式(Schema)来描述一类数据的结构，类似 mongoose 的形式
+ 所有请求都使用 POST 方法，同时将 Schema 作为请求参数放入请求体中

**设计：**

+ 类型：返回后端定义的类型
+ 验证：后端对于不符合要求的 GraphQL 请求会给出明确的错误提示
+ 内省：告诉调用者当前服务器指出哪些查询
+ 查询与变更：查询操作以 `query` 开头，变更操作以 `mutation` 开头


**GraphQL 工具：**

+ GraphiQL
+ GraphQL Voyager