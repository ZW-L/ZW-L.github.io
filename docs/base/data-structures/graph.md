---
sidebarDepth: 2
---

## 概述

+ 图（Graph）是极为常用的数据结构

:::: tabs
::: tab 分类
+ 无向（带权）图
+ 有向（带权）图
:::

::: tab 概念
**基本概念：**
+ 顶点：图中的数据元素称为顶点（vertex）
+ 边：两顶点的连线称为边（edge），无向图为无向边，有向图为有向边（或弧，两顶点分别称为弧头、弧尾）
+ 权重：边可以附带权重（weight），用于表示边的长度、距离等数据
+ 度、入度、出度：无向图的顶点所连接的边的数量称为度；有向图中顶点作为弧头时连接的边的数量为入度，反之为出度

**更多概念：**
+ 有 $\frac{n(n-1)}{2}$ 条边的无向图称为`完全图`，具有 $n(n-1)$ 条弧的有向图称为`有向完全图`
+ 以 $e$ 表示边或弧的数量，其中 $e \le nlogn$ 的图称为`稀疏图`，反之为`稠密图`
+ 连通性：在无向图 $G$ 中，若从顶点 $v_1$ 到顶点 $v_2$ 有路径，则称 $v_1$ 和 $v_2$ 是`连通`的
+ 连通图：若对于图中任意两个顶点 $v_1, v_2 \epsilon V$，$v_1$ 和 $v_2$ 都是连通的，则称 $G$ 为`连通图`
+ 连通分量：若无向图中（最多）存在 $m$ 个顶点能够互相到达，则它们构成一个`连通分量`（极大连通子图）
+ 强连通分量：在有向图中称为`强连通分量`
+ 生成树：是一个极小连通子图，其 $n$ 个顶点有且只有 $n-1$ 条边连接所有顶点，且不构成环
+ 生成森林：由有向图的若干棵有向树组成
:::

::: tab 表示方法
+ 邻接矩阵法：或称数组表示法，使用二维数组表示，每一行代表一个顶点，列代表该顶点到其他顶点的可到达性或权重
  + 无向图：顶点之间只有两种状态，因此二维数组由 0 和 1 填充
  + 有向图：当一顶点不能达到其他顶点时，标记为 $\infty$，否则为相应的权重
+ 邻接（链）表法：使用一维数组存储顶点（随机访问），并对图中每个顶点建立一个单链表（链式存储）存储相关顶点的可到达性和信息

**备注**：表示稀疏图时，邻接表法比邻接矩阵法节省存储空间，当和边相关信息较多时也是如此
:::
::::

+ 图的遍历：是求解`图的连通性问题`、`拓扑排序`、`关键路径`等问题的基础
  + 深度优先遍历（DFS, Depth First Search）：类似树的前序遍历
  + 广度优先遍历（BFS, Breath First Search）：类似树的层序遍历
+ 应用：
  + 拓扑排序
  + 最小生成树
  + 单源最短路径
  + 所有结点对的最短路径
  + 网络流建模

::: tip 备注
+ 树（Tree）是一种特殊的图 —— 有向无环图
+ 无权重的图也可认为它们的权重相同，因此无需考虑
+ 此外，带权图又称为网
:::



## 图的表示

### 邻接矩阵法

+ 无向图
+ 有向图


### 邻接表法

+ 无向图
+ 有向图




## 遍历

### DFS

:::: tabs
::: tab 过程分析
+ DFS 过程会优先访问子节点的后代节点
+ 不难看出，DFS 是一个递归的过程，为了避免重复访问同一节点，需要使用一个`标志数组`或者`哈希表`来记录已访问的节点

复杂度分析：
+ 时间复杂度：$O(n^2)$，每个节点都需要遍历一次，`dfs(v)` 内部会遍历其邻接节点，总时间复杂度为 $O(n^2)$
+ 空间复杂度：$O(n)$，标志数组或哈希表需要 $O(n)$ 的空间，递归调用栈最多为 $O(n)$，总空间复杂度为 $O(2n) = O(n)$
:::

::: tab javascript
```js
function dfsTraverse (G) {
  if (G.length === 0) return
  const count = G.length
  const visited = new Array(count).fill(0)
  dfs(G, 0, visited)
}

function dfs (G, v, visited) {
  visited[v] = 1
  console.log(v) // 打印顶点
  for (let i = 0; i < G[v].length; i++) {
    if (G[v][i] && !visited[i]) {
      dfs(G, i, visited)
    }
  }
}

const G = [
  [0, 1, 1, 0, 0, 0, 0, 0],
  [1, 0, 0, 1, 1, 0, 0, 0],
  [1, 0, 0, 0, 0, 1, 1, 0],
  [0, 1, 0, 0, 0, 0, 0, 1],
  [0, 1, 0, 0, 0, 0, 0, 1],
  [0, 0, 1, 0, 0, 0, 1, 0],
  [0, 0, 1, 0, 0, 1, 0, 1],
  [0, 0, 0, 1, 1, 0, 0, 0]
]
dfsTraverse(G)
```
:::
::::


### BFS

:::: tabs
::: tab 过程分析
+ BFS 过程会优先访问子节点及其兄弟节点
+ 过程同样使用递归完成，因此也需要一个`标志数组`或`哈希表`来记录已访问的节点；同时，还需要一个队列来维持访问的顺序
  1. 初始化：将指定节点入队，更新标志数组 $visited$
  2. 获取队头节点 $v_i$，并出队
  3. 通过遍历，将 $v_i$ 的邻接节点入队，更新标志数组 $visited$
  3. 重复 2~3，直至队列为空，遍历完成

复杂度分析：
+ 时间复杂度：$O(n^2)$，每个节点都需要遍历一次，`bfs(v)` 内部会遍历其邻接节点，总时间复杂度为 $O(n^2)$
+ 空间复杂度：$O(n)$，标志数组或哈希表需要 $O(n)$ 的空间，递归调用栈最多为 $O(n)$，总空间复杂度为 $O(2n) = O(n)$
:::

::: tab javascript
```js
function bfsTraverse (G) {
  if (G.length === 0) return
  const count = G.length
  const visited = new Array(count).fill(0)
  const queue = []
  // 初始化
  queue.push(0)
  visited[0] = 1
  bfs(G, visited, queue)
}

function bfs (G, visited, queue) {
  if (queue.length === 0) return // 遍历完成
  const v = queue.shift()
  console.log(v) // 打印顶点
  // 将顶点 v 的邻接顶点入队
  for (let i = 0; i < G[v].length; i++) {
    if (G[v][i] && !visited[i]) {
      queue.push(i)
      visited[i] = 1
    }
  }
  bfs(G, visited, queue)
}

const G = [
  [0, 1, 1, 0, 0, 0, 0, 0],
  [1, 0, 0, 1, 1, 0, 0, 0],
  [1, 0, 0, 0, 0, 1, 1, 0],
  [0, 1, 0, 0, 0, 0, 0, 1],
  [0, 1, 0, 0, 0, 0, 0, 1],
  [0, 0, 1, 0, 0, 0, 1, 0],
  [0, 0, 1, 0, 0, 1, 0, 1],
  [0, 0, 0, 1, 1, 0, 0, 0]
]
bfsTraverse(G)
```
:::
::::



## 应用

### 拓扑排序




### 最小生成树

两种算法求解最小生成树：
+ kruskal 算法：
+ prim 算法：

::: tip 备注：
+ 两种算法都使用了贪心思想
:::

:::: tabs
::: tab kruskal 算法

:::

::: tab javascript

:::
::::

:::: tabs
::: tab prim 算法

:::

::: tab javascript

:::
::::




### 单源最短路径




### 所有结点对的最短路径




### 网络流建模



