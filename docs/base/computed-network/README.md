---
sidebarDepth: 2
---

## HTTP

### HTTP 历史

&emsp;&emsp;`HTTP`(Hyper Text Transfer Protocol，超文本传输协议)，用于传输 `HTML`(Hyper Text Markup Language，超文本标记语言)文档的一种协议。并且是基于 `TCP` 协议实现的。

+ 1990 年，由 Tim Berners-Lee 提出
+ 1990 年，提出 HTTP/0.9，但没有作为正式的标准
+ 1996 年，推出 HTTP/1.0
+ 1997 年，推出 HTTP/1.1 (当前使用广泛的版本)
+ 2015 年，推出 HTTP/2.0

### 常见 HTTP 状态码

**状态码分类：**

状态码|分类|说明
-|-|-
1xx|信息类|请求已接收，正在处理
2xx|响应成功类|请求已接收、处理且响应成功
3xx|页面重定向类|需要其他操作才能完成请求
4xx|客户端错误类|客户端请求出现错误或不符合服务器预期，导致服务端无法处理请求
5xx|服务端错误类|服务端处理请求时出错

**常见状态码：**

查看[全部状态码](/appendix/http-referrence/status-code)

状态码|标识|含义
-|-|-
200|OK|服务器成功处理并响应客户端的请求。
204|No Content|请求已经成功处理，但是响应主体不返回内容
206|Partial Content|服务端成功处理并返回客户端指定某资源的某部分
301|Moved Permanently|请求的资源被永久移动到指定的 URL 上
302|Found|请求的资源暂时移动到指定的 URL 上
304|Not Modified|请求访问的资源未被修改，可以使用缓存的内容
307|Temporary Redirect|请求的资源暂时被移动到指定的 URL 上
400|Bad Request|客户端请求有语法错误(或请求参数错误)，不能被服务器所理解
401|Unauthorized|请求未经授权
403|Forbidden|服务器有能力处理该请求，但是拒绝授权访问
404|Not Found|服务器无法找到所请求的资源
500|Internal Server Error|服务器遇到不知道如何处理的情况
502|Bad Gateway|网关(或代理服务器)向上游服务器发起请求时得到无效的响应
503|Service Unavailable|服务端暂时处于超负载或正在进行停机维护，无法处理请求
504|Gateway Timeout|网关/代理服务器请求上游服务器/辅助服务器时未能收到响应


### HTTP 请求报文和响应报文的组成



### HTTP 常见请求头的含义

参考 [常见头部字段](/appendix/http-referrence/head-fields)

### HTTP 的状态 & 优缺点

`HTTP` 是无状态的，它对发送过的请求和响应都不做持久化处理：

+ 优点：减轻服务器负担
+ 缺点：不能保存客户端的状态(验证登录等情况时)，但 `HTTP/1.1` 引入了 `Cookie` 技术来缓存状态


### HTTP 请求方式和区别

+ **GET**：用于获取资源。一般来说只用于数据的读取，而不用于会产生副作用的非幂等的操作中
+ **HEAD**：用于获取响应头部。常用于查看服务器的性能
+ **POST**：用于向指定资源提交数据，请求服务器进行处理。如表单数据提交、文件上传等，请求数据会被包含在请求体中；是非幂等的方法，因为这个请求可能会创建新的资源或修改现有资源
+ **DELETE**：用于删除指定内容。
+ **PUT**：用于更新现有资源。
+ **PATCH**：用于资源的部分更新。当资源不存在时创建一个新的资源
+ **OPTIONS**：用于查看服务器的性能。
+ **TRACE**：回显服务器收到的请求。主要用于测试或诊断
+ **CONNECT**：HTTP1.1预留给能够将连接改为管道方式的代理服务器。通常用于 SSL 加密服务器的链接与非加密的 HTTP代理服务器的通信

::: tip 说明：
+ GET, POST, HEAD 都是 HTTP 1.0 的产物
+ JavaScript 使用 XMLHttpRequest 对象进行 CORS 跨域资源共享时，就是使用 OPTIONS 方法发送嗅探请求，以判断是否有对指定资源的访问权限
:::


### GET 和 POST 的区别

+ GET 一般用于请求数据, POST 一般用于发送数据
+ GET 安全性底, POST 安全性较高
+ GET 传递参数大小有限制, POST 将请求参数放进请求体中, 大小没有限制
+ GET 一般会走缓存, POST 不走缓存

### HTTP 请求优化

+ 减少请求/连接
  + 减少请求：优化数据请求，合并请求等
  + 减少连接：保持一定的连接时间，而不是经历多次的 "三次握手"
+ 缓存数据
  + 客户端缓存在 localeStorage 中
  + 服务端缓存静态资源在 CDN 服务器上
+ 减少传输数据量：对文件进行压缩
+ 优化网络链路
  + 减少域名：减少三级或更高级域名的使用，减少域名解析的时间
  + 使用 CDN


### HTTP 的缺点

+ 通信使用明文：HTTP 协议本身不具有加密功能，无法对通信整体进行加密，所以采用明文方式发送
+ 不验证通信方身份：HTTP 协议不具有判断对方身份的机制，容易造成很多安全问题：
  + 客户端无法确认请求发送的服务器是否是目标服务器，有可能是已伪装的 Web 服务器
  + 服务端无法确认接收响应的客户端是否是目标客户端，有可能是已伪装的 Web 客户端
  + 即使是无意义的请求，服务器也会收到，例如 DDOS(Distributed denial of service，拒绝服务)攻击
+ 无法证明报文的完整性：如果中间方篡改了信息，通信双方都没有方法来确认信息的准确性，容易遭受中间人攻击。但可以通过其他方法，如 `数字签名` ，来保证信息的准确性。


### HTTPS 加密原理

+ `HTTP` 的安全版本，通过 `SSL` 加密

::: tip 术语和技术：
**对称加密 & 非对称加密:**
+ 对称加密：`AES`、`DES` 等，加密解密使用同一个密钥
+ 非对称加密：`RSA` 等，有一对密钥(公钥，私钥)，两个密钥都可以加解密，但用其中一个密钥加密就只有用另一个密钥才能解密

**摘要 & 签名:**
+ 消息摘要：使用哈希函数(MD5, SHA 等)将数据生成唯一的定长的字符串，当数据改变时，使用同一哈希函数生成的摘要信息会不一样，从而验证数据的完整性
+ 签名：为了防止消息摘要在中途被篡改，使用加密算法对消息摘要进行加密，只有拥有密钥才能解密

**SSL 数字证书:**
+ 由 CA(认证中心)机构签发：CA 收到制作证书的请求后，会用非对称加密算法生成公钥和私钥，其中公钥保存在生成的 SSL 证书中，并用 CA 自身的私钥进行签名后，把 SSL 证书和对应的私钥返回给申请者
+ SSL 证书的作用：
  + 身份认证，客户端可以认证服务端的身份
  + 加密传递数据：利用 SSL 证书中的公钥加密数据(该数据应该是随机数生成的对称算法密钥)

**使用两种加密算法的原因:**
+ 单独使用非对称加密算法：这样相当于不加密(因为服务端在之前把公钥返回给浏览器，任何人都可能知道公钥)
+ 单独使用对称加密算法：服务端还要跟浏览器约定唯一密钥，保存密钥等工作
+ 同时使用两者：非对称加密算法用于确保对称加密算法的密钥不被窃取，对称加密算法则用于加密数据；这样服务端就不用保留对称加密的密钥，而是通过公钥解密即可
:::

### HTTPS 通信流程

1. 浏览器将自己支持的加密算法发给服务端
2. 服务端选择其中一组加密算法，将自己的 SSL 证书和公钥返回给浏览器
3. 浏览器验证该证书的合法性
4. 若证书合法(或用户接受了不受信任的证书)，浏览器会生成一串随机数密码，并用公钥进行加密后，发送至服务端
5. 服务端接收浏览器的数据后：
    + 用私钥解密出该随机数密码
    + 用该随机数密码解密握手信息
    + 用该随机数密码加密一段握手信息，发送至浏览器
6. 之后的通信都使用该随机数密码作密钥进行加解密

::: tip 说明：
+ 使用了两种加密算法：对称加密、非对称加密
+ 握手信息和数据是用对称加密的，密钥为浏览器生成的随机数密码
+ 该随机数密码是用非对称加密的，公钥一开始和 SSL 证书一并发送给浏览器，服务端保存私钥
:::


### 开启 HTTPS



### 劫持 HTTPS 请求

**中间人攻击**：通过伪造证书，中间人截取客户端发送给服务器的请求，伪装成客户端与服务器进行通信，并将信息转发给客户端，伪装成服务器与客户端进行通信。此时中间人可以获取客户端与服务端的所有通信内容。

**预防**：证书校验。针对安全性比较高的应用，可以采用客户端预埋证书的方式锁死证书，只有当客户端证书与服务端证书完全一致的情况下才允许通信，而且证书过期必须强制更新。


### HTTP 1.0/1.1/2.0 的区别

**HTTP 1.0/1.1**

+ **长连接**：`HTTP 1.0` 需要使用 `keep-alive` 参数来告知服务器建立一个长连接，而 `HTTP 1.1` 默认支持长连接
+ **节约宽带**：`HTTP 1.1` 支持只发送一个 `header` 信息（不带任何 `body` 信息）
+ **`host` 域**：设置虚拟站点，`web server` 上的多个虚拟站点可以共享同一个 `ip` 端口，`HTTP 1.0` 没有 `host` 域

**HTTP 2.0：**

+ **多路复用**：`HTTP 1.1` 为了避免浏览器过度消耗服务器资源，限制了浏览器对同一域名的并发请求数量；而 `HTTP 2.0` 不会
+ **数据压缩**：启用了强制性的压缩算法来压缩报文
+ **支持 `TLS`**：允许使用 `TLS 1.2` 或更新版本的协议进行加密，使通信更加安全
+ **应用层协议协商**
+ **服务端推送**：服务端可以自行判断客户端的请求，选择返回比当前请求更多的数据
+ **流控制**：阻止发送方发送过量的数据，以免超出接收方的处理能力





## WebSocket

### 理解 WebSocket 协议

+ `WebSocket` 在 `HTML5` 中引入，与 `HTTP` 协议一样都是建立在 `TCP` 协议之上的应用层协议，都属于可靠协议
+ `WebSocket` 连接时需要使用 `HTTP` 协议通信
+ `WebSocket` 只需要完成一次握手就能创建持久性连接(`HTTP` 需要三次握手)；它也是有状态的(`HTTP` 是无状态的)，不用再每次发送报文都提供报文信息
+ `WebSocket` 允许双工通信，不仅客户端能向服务端发送消息，而且服务端也能主动向客户端发送消息


### 浏览器使用

**使用全局构造函数：**

```js
const ws = new WebSocket(url, protocols)
```

**参数：**

+ `url: String`: 请求 url 地址
+ `protocols='': Array`: 单个协议名称或包含多个协议的数组

更多实例属性和方法 [HTML5 WebSocket](/base/html/html5/websocket)

### 服务端使用

**Node.js 中使用第三方模块 `ws`：**

```js
const WebSocket = require('ws')
const http = require('ws')

// 两种方式创建 WebSocket 实例
// 1.传入一个对象
const wsServer = new WebSocket.Server({ port: 1234 })

// 2.传入一个 http 实例
const httpServer = new https.createServer()
const wsServer = new WebSocket.Server({ server: httpServer })
```


### 在客户端和服务端通信

```js
// 客户端
const ws = new WebSocket('ws://localhost:1234')
console.log('Try to connect WebSocket Server...')

ws.addEventListener('open', () => {
  console.log('Connect Success!')
  ws.send('Client: Hi, WebSocket!')
})

ws.addEventListener('message', event => {
  console.log(event.data)
})

// 服务端
const WebSocket = require('ws')
const wss = new WebSocket.Server({ port: 1234 })

wss.on('connection', ws => {
  console.log('Server connection success!')
  ws.on('message', message => {
    console.log('received: %s', message)
    ws.send(message)
    ws.send('Server: Hello, I\'m WebSocket!')
  })
})
```


## URL

### 认识 URL

**URL 地址：**

```
https://www.zwlike.top:3000/blog/index.html?tag=note&limit=10#/main
```

**分析：**

+ 协议（protocol）：`http`, `https`, `ftp` 等
+ 主机名（hostname）：域名(`www.zwlike.top`)或 `IP` 地址
+ 端口（port）：`3000`，在服务器地址和一个 `:` 标识后的数字(没有则使用默认端口)
+ 请求路径（path）：`/blog/index.html`，指示服务器下的文件相对路径
+ 请求参数（query）：`tag=note&limit=10`，以 `?` 标识开始，且以 `key=value` 形式的单组或多组(用 `&` 分隔)的查询参数
+ 片段标识符（hash）：`#/main`，用 `<a>` 标签作锚点的跳转定位页面位置或 HTML5 的单页应用劫持跳转使请求路径和参数发生的变化

::: tip 说明：
+ `HTTP` 默认端口为 `80`，`HTTPS` 默认端口为 `443`
:::






## CDN

### CDN 的作用和原理

**CDN**：内容分发网络。尽可能的避开互联网有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输的更快更稳定。

**原理**：

+ 广泛采用各种缓存服务器，将这些缓存服务器分布到用户访问相对的地区或者网络中
+ 将用户的访问指向距离最近的缓存服务器，由缓存服务器直接响应用户的请求



## Cookie

&emsp;&emsp;由于 `HTTP` 是无状态的，不能保存客户端的状态(验证登录等情况时)，因此 `HTTP/1.1` 引入了 `Cookie` 技术来缓存状态。

### 分类

+ 持久化 `Cookie`: 保存在硬盘中，由一个过期时间(或被用户手动清理)
+ 非持久化 `Cookie`: 保存在内存中，相当于临时缓存，在浏览器关闭后消失

### 使用

+ 请求报文的 `Cookie` 字段: `Cookie`
+ 响应报文的 `Cookie` 字段: `set-Cookie`，可以使用多个该字段，并且可以使用以下几个附加属性(`键=值` 的形式，多个属性间用 `;` 分隔): 
  + `expires`: 指定数据的有效期，否则默认在浏览器关闭后消失；而且当 `Cookie` 从浏览器发出后就无法直接删除，只能覆盖
  + `path`: 指定 `Cookie` 发送范围的路径，默认为根路径
  + `domain`: 指定 `Cookie` 适用的域名，匹配规则为结尾匹配
  + `secure`: 指定 `Cookie` 只能在 HTTPS 安全连接中使用，默认可在 HTTP/HTTPS 中使用
  + `HttpOnly`: 指定浏览器端的 Javascript 脚本无法获取 `Cookie` 内容(从而无法轻易修改或删除)，常用于防止跨站脚本(XSS)对 `Cookie` 信息的窃取


### 缺陷

+ 大小受限，浏览器限制为 4KB 左右
+ 消耗网络带宽
+ 可以被客户端禁用的
+ 可能会被窃取或篡改
+ 场景受限，有些端不支持 `Cookie`(微信小程序)


### 对比其他存储

存储方式|说明|容量|特点
-|-|-|-
Cookie|服务端设置，分为持久化 Cookie和非持久化 Cookie|4KB 左右|容量小，可被禁用，可能被窃取或篡改，在同源窗口中共享的
Session Storage|浏览器全局对象，非持久化存储|5MB|只能存储简单数据(复杂数据只能 json 化)，页面关闭后清除，不同域之间不共享
Locale Storage|浏览器全局对象，持久化存储|5MB|只能存储简单数据(复杂数据只能 json 化)，不会消失，除非手动清除，在同源窗口中共享的
Indexed DB|浏览器非关系型数据库(NoSQL)|-|直接将数据存储在浏览器端的数据库中


### Cookie 与状态

&emsp;&emsp;在 `Cookie` 的使用场景中，最重要的是授权认证。授权认证的常用方式有两种：基于 `Cookie`、基于 `Token`，他们的实现有所不同，但步骤大致相同。


**授权认证的步骤：**

+ 保存登录状态信息：浏览器发送 `POST` 请求提交登录信息 --> 服务端响应信息、验证通过并返回一个状态值来保存登录状态
+ 提取登陆状态信息：登录完成后 --> 浏览器发送请求，服务端总能获取浏览器的登录状态，从而正确响应页面


**授权认证的方式：**

+ 基于 `Cookie`
  1. 服务端收到浏览器请求后，创建一个 `Session` 会话，保存在服务端的内存或数据库中
  2. 接着生成一个随机的、唯一的 id，用来和会话信息进行映射并写入 `Cookie`，该 `Cookie` 通常带 `HttpOnly` 属性
+ 基于 `Token`
  1. 服务端收到浏览器请求后，对用户信息进行编码(生成一串较长的字符串)
  2. 将该字符串作为 `Token` 字段的属性值，返回给浏览器


**两种认证方式的主要区别：**

+ 基于 `Cookie`：有状态。获取状态时，服务端要获取请求头部的 `Cookie` 字段的 `Session` 属性值，再找到之前保存在服务端的会话信息进行校验；这种方式需要客户端和服务端都保存信息
+ 基于 `Token`：无状态。获取状态时，直接利用密钥信息对 `Token` 进行解密和校验；这种方式下服务端不用保存信息，能够减轻服务端的压力，也可用于不支持 `Cookie` 的情况(微信小程序)


**基于 Token 的优点：**

+ **无状态**: 服务端不用保存状态信息，减轻服务端压力
+ **域无关**: `Cookie` 与域有关，`Token` 与域无关
+ **性能好**: 请求头部会自动带上 `Cookie`，占用带宽，而 `Token` 则可以按需添加；另外服务端收到 `Cookie` 后可能要在数据库中查询认证，而 `Token` 则直接解密认证
+ **通用性强**: 很多设备(或小程序等应用)不支持 `Cookie`，而且 `Cookie` 可以被用户禁用，因此 `Token` 通用性更好


**创建 Token 的方式：**

使用最多的是 `JSON Web Token`，简称 `JWT`。该方式生成的 `Token` 分为三个部分(通过 `.` 分割)：

+ `Header`: 头部。由算法和 `Token` 类型组成，属性名使用简写: `{ "alg": "HS256", "typ": "JWT" }`
+ `Payload`: 负载。
+ `Signature`: 签名。


## 理解和区别 Token/Cookie/Session

+ `Cookie`：
  + 浏览器里面能永久存储的一种数据，由服务器生成，发送给浏览器
  + 浏览器把 `Cookie` 以 `k-v` 形式保存到某个目录下的文本文件内，下一次请求同一网站时会把该 `Cookie` 发送给服务器
  + 浏览器加入了一些限制确保 `Cookie` 不会被恶意使用，同时每个域的 `Cookie` 数量是有限的
+ `Session`：
  + 会话，服务器给客户端分配的不同的身份标识，客户端每次向服务器发请求的时候都带上这个身份标识
  + 在基于 `Session` 的身份验证中，服务器将在用户登录后为用户创建一个 `Session`。然后，`Session ID` 会被存储在用户浏览器的 `Cookie` 中。当用户保持登录状态时，`Cookie` 将与每个后续请求一起被发送出去。然后，服务器可以将存储在 `Cookie` 上的 `Session ID` 与存储在内存中或者数据库中的 `Session` 信息进行比较，以验证用户的身份，返回给用户客户端响应信息的时候会附带用户当前的状态
  + 客户端有多种方式保存这个身份标识，浏览器端一般采用 `Cookie` 的方式
  + 服务器使用 `Session` 把用户的信息临时保存在服务器上，用户离开网站后 `Session` 会被销毁，这种用户信息存储方式相对 `Cookie` 来说更安全，但是有一个缺陷：如果 Web 服务器做了负载均衡，那么下一个操作请求到另一台服务器的时候`Session` 会丢失
+ `Token`：
  + 无状态：基于 `Token` 的身份验证是无状态的，不将用户信息存在服务器或 `Session`
  + 安全性：`Token` 是有时效的，一段时间之后用户需要重新验证，也可以手动撤回 `Token`
  + 可扩展性：`Token` 能够创建与其它程序共享权限的程序
  + 多平台跨域：只要用户有一个通过了验证的 `Token`，数据和资源就能够在任何域上被请求到
  + 基于标准：创建 `Token` 的时候，可以设定一些选项




## 服务端 API

&emsp;&emsp;服务端 `API`(Application Programming Interface，应用程序编程接口)，在程序内部指的是各个模块、函数、类的调用参数和返回值，在程序外部指不同程序之间的调用参数和返回结果。在 Web 中指的是前后端通信的接口，一般借助 HTTP(S) 协议来实现。

&emsp;&emsp;当前流行的 Web API 设计规范为 `REST API` 和 `GraphQL`。


### REST API

&emsp;&emsp;简称 `REST`(Representation State Transfer，表现层状态转换)，指的是一种设计风格(不是标准)。

**特点：**

+ 所有通信都是无状态的，状态统一由客户端进行维护，减轻了服务端的压力
+ 可以利用缓存来提升通信效率
+ 可结合一些 HTTP 协议的特点：用 URL 的方式指向不同的资源


**定制团队规范：**

+ **请求路径**
  + 所有请求路径对应特点的资源，不要包含动词、形容词等修饰符，必要时应该使用复数
  + 多个单词组合使用 `songList`, `song_list`, `song-list` 三者之一
  + 合适的资源嵌套层级，使用 id 占位符(`:id`)标识资源
  + 用参数对资源进行过滤而不是使用无规则的 URL，参数之间用 `&` 分开，多个参数值用 `,` 分开
+ **请求头部**: 不同的操作使用对应语义的请求方法
  + `GET`: 获取资源，常用于查询
  + `POST`: 创建资源，或数据提交(用户登录等)
  + `PUT`: 修改资源
  + `DELETE`: 删除资源
+ **请求体**: 一般采用 JSON 格式提交数据(文件上传除外)
+ **响应头部**: 遵循 HTTP(S) 规范的状态码和状态信息描述请求结果
+ **响应体**
  + 一般响应为 JSON 格式
  + 响应结果处理: 包括响应描述和响应分页


**工具：**

+ Swagger



### GraphQL

&emsp;&emsp;简称 `GraphQL`(Graph Query Language，图表化查询语言)，由 `Facebook` 推出。


**特点：**

+ 它使用模式(Schema)来描述一类数据的结构，类似 mongoose 的形式
+ 所有请求都使用 POST 方法，同时将 Schema 作为请求参数放入请求体中


**设计：**

+ **类型**: 返回后端定义的类型
+ **验证**: 后端对于不符合要求的 GraphQL 请求会给出明确的错误提示
+ **内省**: 告诉调用者当前服务器指出哪些查询
+ **查询与变更**: 查询操作以 `query` 开头，变更操作以 `mutation` 开头


**工具：**

+ GraphiQL
+ GraphQL Voyager

