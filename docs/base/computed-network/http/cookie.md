---
sidebarDepth: 2
---

## 介绍

+ `HTTP` 是无状态的，不能保存客户端的状态(验证登录等情况时)，`HTTP/1.1` 引入了 `Cookie` 技术来缓存状态
+ 是浏览器里面能永久存储的一种数据，由服务器生成，发送给浏览器
+ 浏览器把 `Cookie` 以 `k-v` 形式保存到某个目录下的文本文件内，下次请求同一网站时会携带该 `Cookie`
+ 浏览器加入一些限制确保 `Cookie` 不会被恶意使用，且每个域的 `Cookie` 数量是有限的
+ 分类
  + 持久化 `Cookie`: 保存在硬盘中，有一个过期时间(或被用户手动清理)
  + 非持久化 `Cookie`: 保存在内存中，相当于临时缓存，在浏览器关闭后消失
+ 缺陷
  + 消耗网络带宽
  + 可以被客户端禁用
  + 可能会被窃取或篡改
  + 大小受限，浏览器限制为 4KB 左右
  + 场景受限，有些端不支持 `Cookie`(微信小程序)



### 使用

+ 请求报文的 `Cookie` 字段: `Cookie`
+ 响应报文的 `Cookie` 字段: `set-Cookie`，可以使用多个该字段，并且可以使用以下几个附加属性(`键=值` 的形式，多个属性间用 `;` 分隔): 
  + `expires`: 指定数据的有效期，否则默认在浏览器关闭后消失；而且当 `Cookie` 从浏览器发出后就无法直接删除，只能覆盖
  + `path`: 指定 `Cookie` 发送范围的路径，默认为根路径
  + `domain`: 指定 `Cookie` 适用的域名，匹配规则为结尾匹配
  + `secure`: 指定 `Cookie` 只能在 HTTPS 安全连接中使用，默认可在 HTTP/HTTPS 中使用
  + `HttpOnly`: 指定浏览器端的 Javascript 脚本无法获取 `Cookie` 内容(从而无法轻易修改或删除)，常用于防止跨站脚本(XSS)对 `Cookie` 信息的窃取


### 对比其他存储

存储方式|说明|容量|特点
-|-|-|-
Cookie|服务端设置，分为持久化和非持久化|4KB 左右|容量小，可被禁用，可能被窃取或篡改，在同源窗口中共享的
Session Storage|浏览器全局对象，非持久化存储|5MB|只能存储简单数据(复杂数据只能 json 化)，页面关闭后清除，不同域之间不共享
Locale Storage|浏览器全局对象，持久化存储|5MB|只能存储简单数据(复杂数据只能 json 化)，不会消失，除非手动清除，在同源窗口中共享的
Indexed DB|浏览器非关系型数据库(NoSQL)|-|直接将数据存储在浏览器端的数据库中




## 授权认证

+ 在 `Cookie` 的使用场景中，最重要的是授权认证
+ 授权认证的常用方式有两种：基于 `Cookie`、基于 `Token`，他们的实现有所不同，但步骤大致相同
  + 保存登录状态信息：浏览器发送 `POST` 请求提交登录信息 --> 服务端响应信息、验证通过 --> 返回一个状态值来保存登录状态
  + 提取登陆状态信息：登录完成后 --> 浏览器发送请求时服务端总能获取浏览器的登录状态，从而正确响应页面


### 基于 Cookie

+ 原理：
  1. 服务端收到浏览器请求后，创建一个 `Session` 会话，保存在服务端的内存或数据库中
  2. 生成一个随机、唯一的 id 来和会话信息进行映射并写入 `Cookie`(通常带 `HttpOnly` 属性)


::: tip Session 简介：
+ `Session`(会话)：服务器给客户端分配的唯一身份标识，客户端每次向服务器发请求的时候都会带上
+ **客户端保存**：有多种方式，浏览器端一般采用 `Cookie` 的方式
+ **服务器保存**：使用 `Session` 把用户的信息临时保存在服务器上，用户离开网站后 `Session` 会被销毁
+ **过程**：
  + 服务器将在用户登录后为用户创建一个 `Session`(存储在内存中或数据库中)
  + `Session ID` 会被返回并存储在用户浏览器的 `Cookie` 中
  + 当用户保持登录状态时，`Cookie` 将与每个后续请求一起被发送
  + 服务器将请求头的 `Cookie` 中的 `Session ID` 与服务器上的 `Session` 信息进行校验以验证用户身份
  + 返回客户端响应信息时会附带用户当前的状态
+ **缺陷**：
  + 如果 Web 服务器做了负载均衡，那么下一个操作请求到另一台服务器的时候`Session` 会丢失
  + 需要浏览器和服务端同时保存，占用服务器资源
  + 每次请求都携带 `Cookie`，占用带宽
  + 服务端验证时有可能要查询数据库校对，影响性能
+ 此外，这些缺陷在基于 Token 的验证中都不存在
:::


### 基于 Token

+ 原理：
  1. 服务端收到浏览器请求后，对用户信息进行编码(生成一串较长的字符串)
  2. 将该字符串作为 `Token` 字段的属性值，返回给浏览器
+ 创建 Token：使用最多的是 `JSON Web Token`(`JWT`)，生成的 `Token` 分为三个部分(`.` 分割)：
  + `Header`(头部): 由算法和 `Token` 类型组成，属性名使用简写: `{ "alg": "HS256", "type": "JWT" }`
  + `Payload`(负载): 包括预定义声明字段(已注册声明、公共声明)和私有声明字段(通常在这里扩展)
  + `Signature`(签名): 
+ 可使用 `JWT` 提供的 [Debugger](https://jwt.io/#debugger-io) 工具生成和校验 Token


::: tip 两种认证方式的主要区别
+ 基于 `Cookie`：有状态。获取状态时，服务端要获取请求头部的 `Cookie` 字段的 `Session` 属性值，再找到之前保存在服务端的会话信息进行校验；这种方式需要客户端和服务端都保存信息
+ 基于 `Token`：无状态。获取状态时，直接利用密钥信息对 `Token` 进行解密和校验；这种方式下服务端不用保存信息，能够减轻服务端的压力，也可用于不支持 `Cookie` 的情况(微信小程序)
:::


::: tip 基于 Token 的优点
+ **无状态**: 服务端不用保存状态信息，减轻服务端压力
+ **域无关**: `Cookie` 与域有关，不能跨域共享
+ **安全性高**：`Token` 是有时效的，一段时间之后用户需要重新验证；也可手动撤回 `Token`
+ **性能好**: 
  + 请求头部会自动带上 `Cookie`(占用带宽)，`Token` 则可以按需添加
  + 服务端收到 `Cookie` 后可能要在数据库中查询认证，`Token` 则直接解密认证
+ **通用性强**: 
  + 很多设备(或小程序等应用)不支持 `Cookie`
  + `Cookie` 可以被用户禁用
+ **可扩展性**：`Token` 能够创建与其它程序共享权限的程序
+ **多平台跨域**：只要用户有一个通过了验证的 `Token`，数据和资源就能够在任何域上被请求到
+ **基于标准**：创建 `Token` 的时候，可以设定一些选项
:::