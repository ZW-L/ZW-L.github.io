---
sidebarDepth: 2
---

## 介绍

+ `HTTP`(Hyper Text Transfer Protocol，超文本传输协议)，用于传输 `HTML` 文档的一种协议
+ 是基于 TCP 协议实现的应用层协议
+ 是无状态的，它对发送过的请求和响应都不做持久化处理：
  + 优点：减轻服务器负担
  + 缺点：不能保存客户端的状态(验证登录等情况时)，但 `HTTP/1.1` 引入 Cookie 技术来缓存状态
+ 历史
  + 1990 年，由 Tim Berners-Lee 提出
  + 1990 年，提出 HTTP/0.9，但没有作为正式的标准
  + 1996 年，推出 HTTP/1.0
  + 1997 年，推出 HTTP/1.1 (当前使用广泛的版本)
  + 2015 年，推出 HTTP/2.0



## 版本区别

+ **1.1 VS 1.0**
  + **长连接**：`1.1` 默认支持长连接；`1.0` 需要使 `keep-alive` 参数来告知服务器建立一个长连接
  + **节约宽带**：`1.1` 支持只发送一个 `header` 信息（不带任何 `body`）
  + **host域**：虚拟站点，服务器上的多个虚拟站点可以共享同一个 `ip` 端口；`1.0` 没有 `host` 域
+ **2.0**
  + **多路复用**：`1.1` 为了避免浏览器过度消耗服务器资源，限制了浏览器对同一域名的并发请求数量；`2.0` 不会
  + **数据压缩**：启用了强制性的压缩算法来压缩报文
  + **TLS 支持**：允许使用 `TLS 1.2` 或更新版本的协议进行加密，使通信更加安全
  + **应用层协议协商**
  + **服务端推送**：服务端可以自行判断客户端的请求，选择返回比当前请求更多的数据
  + **流控制**：阻止发送方发送过量的数据，以免超出接收方的处理能力



## 请求方法

### 可用方法

|请求方法|描述|
|-|-|
|**GET**|用于获取资源。一般来说只用于数据的读取，而不用于会产生副作用的非幂等的操作中
|**HEAD**|用于获取响应头部。常用于查看服务器的性能
|**POST**|用于向指定资源提交数据，请求服务器进行处理。如表单数据提交、文件上传等，请求数据会被包含在请求体中；是非幂等的方法，因为这个请求可能会创建新的资源或修改现有资源
|**DELETE**|用于删除指定内容
|**PUT**|用于更新现有资源
|**PATCH**|用于资源的部分更新。当资源不存在时创建一个新的资源
|**OPTIONS**|用于查看服务器的性能
|**TRACE**|回显服务器收到的请求。主要用于测试或诊断
|**CONNECT**|HTTP1.1 预留给能够将连接改为管道方式的代理服务器。通常用于 SSL 加密服务器的链接与非加密的 HTTP代理服务器的通信

::: tip 说明：
+ `GET`, `POST`, `HEAD` 都是 HTTP 1.0 的产物
+ JavaScript 使用 XMLHttpRequest 对象进行 CORS 跨域资源共享时，就是使用 `OPTIONS` 方法发送嗅探请求，以判断是否有对指定资源的访问权限
:::


### GET VS POST

|方法|行为|安全性|请求参数|缓存|
|-|-|-|-|-|
|GET|一般用于请求数据|低|限制大小|一般走缓存|
|POST|一般用于发送数据|较高|无限制，放进请求体中|不走缓存|





## 报文

### 请求报文

+ 组成：

![请求报文](../imgs/request-message.png)

+ 请求报文头部示例：
```sh
# 请求行
GET /home/msg/data/personalcontent?num=8 HTTP/1.1
# 请求头部字段
Host: www.baidu.com
Connection: keep-alive
Pragma: no-cache
Cache-Control: no-cache
Accept: text/plain, */*; q=0.01
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/83.0.4103.106 Safari/537.36
X-Requested-With: XMLHttpRequest
Sec-Fetch-Site: same-origin
Sec-Fetch-Mode: cors
Sec-Fetch-Dest: empty
Referer: https://www.baidu.com/?tn=62095104_19_oem_dg
Accept-Encoding: gzip, deflate, br
Accept-Language: zh-CN,zh;q=0.9
Cookie: BIDUPSID=1B90A499A1F594A342FC57A545380BF2;
```


### 响应报文

+ 组成：

![响应报文](../imgs/response-message.png)

+ 响应报文头部示例：
```sh
# 状态行
HTTP/1.1 200 OK
# 响应头部字段
Cache-Control: private
Connection: keep-alive
Content-Encoding: gzip
Content-Type: text/html;charset=utf-8
Date: Thu, 18 Jun 2020 17:26:03 GMT
Expires: Thu, 18 Jun 2020 17:26:03 GMT
Server: BWS/1.0
Vary: Accept-Encoding
Content-Length: 47
```




## 请求优化

+ **减少数量**
  + 减少请求次数：优化数据请求，合并请求等
  + 减少连接次数：保持一定的连接时间，而不是经历多次的 "三次握手"
+ **缓存数据**
  + 客户端缓存在 localeStorage 中
  + 服务端缓存静态资源在 CDN 服务器上
+ **减少传输数据量**
  + 对文件进行压缩
+ **优化网络链路**
  + 减少域名：减少三级或更高级域名的使用，减少域名解析的时间
  + 使用 CDN



## HTTP 的缺点

+ **通信使用明文**：HTTP 协议本身不具有加密功能，无法对通信整体进行加密，所以采用明文方式发送
+ **不验证通信方身份**：HTTP 协议不具有判断对方身份的机制，容易造成很多安全问题：
  + 客户端无法确认请求发送的服务器是否是目标服务器，有可能是已伪装的 Web 服务器
  + 服务端无法确认接收响应的客户端是否是目标客户端，有可能是已伪装的 Web 客户端
  + 即使是无意义的请求，服务器也会收到，例如 DDOS(Distributed denial of service，拒绝服务)攻击
+ **无法证明报文的完整性**：如果中间方篡改了信息，通信双方都没有方法来确认信息的准确性，容易遭受中间人攻击；但可以通过其他方法，如 `数字签名` ，来保证信息的准确性。




## HTTPS 简介

+ HTTP 的安全版本，通过 `SSL` 加密


### 开启

+ 主要步骤为：申请 SSL 证书 --> 部署证书
+ 以阿里云为例：
  1. 申请特定域名的免费证书(国内域名必须备案，且证书是针对单个域名的，各级域名不通用)
  2. 下载适用于特定服务器(Apache, Nginx 等)的证书
  3. 上传证书到服务器，并配置


### 加密原理

+ **对称加密 & 非对称加密:**
  + 非对称加密：`RSA` 等，有一对密钥(公钥，私钥)，两个密钥都可以加解密，但用其中一个密钥加密就只有用另一个密钥才能解密
  + 对称加密：`AES`、`DES` 等，加密解密使用同一个密钥
+ **摘要 & 签名:**
  + 消息摘要：使用哈希函数(MD5, SHA 等)将数据生成唯一的定长的字符串，当数据改变时，使用同一哈希函数生成的摘要信息会不一样，从而验证数据的完整性
  + 签名：为防止消息摘要在中途被篡改，使用加密算法对消息摘要进行加密，只有拥有密钥才能解密
+ **SSL 数字证书签发:**
  1. CA(认证中心/机构) 收到制作证书的请求后，用非对称加密算法生成公钥和私钥
  2. 公钥保存在生成的 SSL 证书中
  3. 用 CA 自身的私钥进行签名后，把 SSL 证书和对应的私钥返回给申请者
+ **SSL 数字证书的作用**：
  + 身份认证，客户端可以认证服务端的身份
  + 加密传递数据：利用 SSL 证书中的公钥加密数据(该数据应该是随机数生成的对称算法密钥)


::: tip 为什么要同时使用两种加密算法：
+ 只使用非对称加密：相当于不加密(因为服务端在之前把公钥返回给浏览器，任何人都可能知道公钥)
+ 只使用对称加密：服务端还要跟浏览器约定唯一密钥，保存密钥等工作
+ 同时使用：非对称加密算法确保对称加密算法的密钥不被窃取，对称加密算法用于加密数据；这样服务端就不用保留对称加密的密钥，而是通过公钥解密即可
:::


### 通信流程

1. 浏览器将自己支持的加密算法发给服务端
2. 服务端选择其中一组加密算法，将自己的 SSL 证书和公钥返回给浏览器
3. 浏览器验证该证书的合法性
4. 若证书合法(或用户接受了不受信任的证书)，浏览器会生成一串随机数密码，并用公钥进行加密后，发送至服务端
5. 服务端接收浏览器的数据后：
    + 用私钥解密出该随机数密码
    + 用该随机数密码解密握手信息
    + 用该随机数密码加密一段握手信息，发送至浏览器
6. 之后的通信都使用该随机数密码作密钥进行加解密

::: tip 说明：
+ 使用了两种加密算法：对称加密、非对称加密
+ 握手信息和数据是用对称加密的，密钥为浏览器生成的随机数密码
+ 该随机数密码是用非对称加密的，公钥一开始和 SSL 证书一并发送给浏览器，服务端保存私钥
:::


### 劫持

+ **中间人攻击**：通过伪造证书，中间人截取客户端发送给服务器的请求，伪装成客户端与服务器进行通信，并将信息转发给客户端，伪装成服务器与客户端进行通信。此时中间人可以获取客户端与服务端的所有通信内容。
+ **预防**：证书校验。针对安全性比较高的应用，可以采用客户端预埋证书的方式锁死证书，只有当客户端证书与服务端证书完全一致的情况下才允许通信，而且证书过期必须强制更新。