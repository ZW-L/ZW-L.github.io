## 简介

+ 总结：
  + 算法指标，算法分析的方法
  + 常用算法思想
  + 数据结构使用技巧
+ 更多题型、解法参考 [LeetCode](https://leetcode-cn.com/)
  + [🔥 LeetCode 热题 HOT 100](https://leetcode-cn.com/problemset/leetcode-hot-100/)
  + [🧡 LeetCode 精选算法 200 题](https://leetcode-cn.com/problemset/leetcode-200/)
  + [👨‍💻 LeetCode 精选 TOP 面试题](https://leetcode-cn.com/problemset/leetcode-top/)


## 算法指标

首先了解衡量算法性能的函数增长记号（平时用的最多的是 $O$ 记号）：
+ $\Theta$：渐近紧确界，渐近给出了函数的上界和下界
+ $O$：渐近上界
+ $\Omega$：渐近下界
+ $o$：非渐近紧确的上界
+ $\omega$：非渐近紧确的下界


再学习从两个方面来衡量算法的性能：

+ 时间复杂度：算法运行至得到结果所需要的时间量度
+ 空间复杂度：算法运行至得到结果所需要额外使用的物理内存

::: tip 备注
空间复杂度是指除程序的返回内容外，额外使用的空间；如算法接受一个数组，要求返回一个全新的等长的数组，该数组空间不会算入空间复杂度
:::


以及更高级的分析技巧 —— 摊还分析：
+ 聚合分析
+ 核算法
+ 势能法
+ 动态表


::: tip 备注：
+ 虽然不必每一步都亲自去证明（建议去做），但是基本的复杂度分析还是要有的，不管是在面试中，还是在编码过程，这都体现了你对所写程序在未来运行的预测能力、以及性能优化的定位
+ 但是，多学一些数学还是好的，不仅能提高逻辑思维，还能提高分析和解答算法问题的速度、准确性
:::



## 算法思想

数据结构只用于辅助算法，而算法思想是算法的灵魂：

+ `枚举`：即暴力求解，这个过程往往只使用循环去迭代问题的解，属于最简单且行之有效的方法；但随着问题的复杂化，算法往往变得更为复杂（更多的判断），以及更高的时间/空间渐进复杂度
+ `递归`：只有问题和子问题存在递推关系，就可以使用递归，递归唯一的代价是会使用额外的调用栈空间
+ `回溯法`：使用 “剪枝” 的方法减少问题的求解规模，在一定条件下退出当前子问题求解，返回到父问题重新选择
+ `分治法`：使用 “分而治之” 的思想，当问题拆分的子问题的解能反映问题的解时，只要将子问题拆分得足够小，再将子问题合并即可得到问题的解
+ `动态规划`：与分治法类似，都是使用子问题来求解问题（该问题通常为最优解问题），但这个子问题通常是指重叠（重复计算）子问题（而分治法是全新的同类型子问题）；另外，动态规划一般都是通过 “备忘录” 来记录子问题的解，当所有子问题都求解完毕，才开始求解问题，算法实现通常都是`自底向上`的
+ `贪心法`：类似动态规划，都包含`最优子结构性质`（即问题的最优解包含子问题的最优解），但其`贪心选择性质`使它不一定能求解问题最优解（但大多数情况下是最优解）；另外，贪心法一般都是进行了贪心选择后采取求解子问题（动态规划要先求解子问题才做选择），算法实现通常都是`自顶向下`的
+ `分支界限`：
+ `位运算`：程序进行位操作是非常快的，使用位运算（`<<`, `>>`, `>>>`, `~`, `&`, `|`, `^`）能够快速求解问题；最关键的问题在于如何将问题转化为位问题
+ `双指针`：以及滑动窗口问题
+ `前缀和`：


::: tip 备注：
+ 枚举是很重要的，可以说只要有循环就有枚举的存在，它可以帮助我们去分析问题的解，以及如何从当前的解去进行优化
+ 递归是很常用的，很多重要的数据结构(链表、树、图等)或其他算法思想(回溯法、分治法、动态规划、贪心法)都使用了递归；熟练掌握递归，对深入算法十分有帮助
+ 动态规划属于比较复杂的算法，它和分治法、贪心法都有些类似，所以要明确三者的使用场景
+ 之所以将位运算归纳为算法思想，是因为若问题可转化为 “位” 的操作去求解时，算法复杂度通常可以极大地降低，甚至是常量复杂度
+ 其他有用的思想：
  + 转化思想：复杂的问题大多数都是可以转化、拆解为简单的问题的
  + 拆分循环：强行将代码放到一个循环里，有时候代码会十分臃肿而且难以理解，并列循环不会增加太多的时间复杂度，但可以让编程更容易
:::



## 算法分类

首先总结常用数据结构的相关算法，剖析其解法及思路：
+ 字符串
+ 数组：$O(1)$ 的存取、设置时间复杂度，$O(n)$ 的删除、插入时间复杂度
+ 链表：$O(n)$ 的存取、设置时间复杂度，$O(1)$ 的删除、插入时间复杂度
+ 栈
+ 队列
+ 哈希表：$O(1)$ 的存取时间复杂度，$O(n)$ 的空间复杂度
+ 堆
+ 优先队列
+ 树
  + 二叉树
  + 并查集
  + 树状数组
  + 线段树
+ 图
+ 布隆过滤器


然后是一些分类算法：
+ 排序算法
+ 查找算法
+ 数论算法
+ 位算法
<!-- + 多线程算法 -->


::: tip 备注：
+ 数据结构和算法相辅相成：算法求解的过程通常要使用数据结构的辅助，而数据结构的实现过程也蕴含了众多的算法思想
+ 在我看来，以分类的方式学习算法，有两大优点：
  1. 加深对数据结构的掌握，如其实现方式、使用场景
  2. 更好地磨合数据结构和算法的关系，如在你选择了一个算法后便知道随后需要使用的数据结构，或是在选择一种数据结构后便知道其常用的算法；使分析问题的速度加快以及提高其准确程度
:::




## 高效刷算法

### 要量力而为

+ 先解决问题再去优化：不要一昧地寻求最简单最快的方法，由浅及深更容易理解和学习，多看题解，多做笔记
+ 不是所有算法你都能解出来，积累多了便更容易了，要给自己一个时间限制：
  + 思考 15~30 分钟，思考不出完整解法就去看题解，然后对比自己想到了多少，如 80%，做个标注，下次遇到的时候可以对比一下自己是进步了还是遗忘了
  + 代码 15~30 分钟，不能通过就看题解；对比自己的代码，哪里不行的做个标注（能提升代码能力）

::: tip 两种刷题方法：
+ “龟” 法：追求算法深入和理解，适合学生、空闲时间多时
+ “兔” 法：追求量，适合面试期间抱佛脚、阶段性的总结
:::



### 善用 LeetCode

+ 选择编程语言：建议 `C++`/`Java`/`Python` 三选一，主要是性能好、方便（有现成的数据结构、参考代码多）
+ 每日一题：坚持签到是好习惯（坚持独立完成、认真看题解而不总是 CV）；坚持练习，总会有游刃有余的一天
+ 题解 & 笔记：毋需多说，多做笔记，如果加上日期的标注，下次再见时，便知道自己是否有所进步
+ 收藏夹：LeetCode 的分类规则可能不适用于每个人，多对题目和知识点分类，汇总重要、高频算法
+ 周赛：不用非得刷到几百题才去竞赛，熟悉数据结构和算法思想，每个类型做了几个题，总量 50 题左右就可以去参赛了；成绩不好不可耻，只有看到了和别人的差距才有更好的动力，同时竞赛也是阶段性测试的一个好手段


### 谨慎使用语法糖

+ 一些语言的语法糖可能会使性能下降：如 JavaScript 数组的解构赋值
```js
// 解构赋值
let a = 1, b = 2
[a, b] = [b, a + b]

// 临时变量
let a = 1, b = 2, temp
temp = b
b = a + b
a = temp

// 由于解构赋值内部使用了 Iterator，导致空间复杂度会增加
// 使用 benchmark 测试：解构赋值方式比临时变量方式慢 30%
```
