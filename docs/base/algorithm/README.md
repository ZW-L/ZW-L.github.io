## 算法指标

首先了解衡量算法性能的函数增长记号：
+ $O$
+ $o$
+ $\Theta$
+ $\Omega$
+ $\omega$

::: tip 备注
平时用的最多的是 $O$ 记号
:::


再学习从两个方面来衡量算法的性能：

+ 时间复杂度：算法运行至得到结果所需要的时间量度
+ 空间复杂度：算法运行至得到结果所需要额外使用的物理内存

::: tip 备注
空间复杂度是指除程序的返回内容外，额外使用的空间；如算法接受一个数组，要求返回一个全新的等长的数组，该数组空间不会算入空间复杂度
:::


以及更高级的分析技巧 —— 摊还分析：
+ 聚合分析
+ 核算法
+ 势能法
+ 动态表


::: tip 备注：
+ 虽然不必每一步都亲自去证明（建议去做），但是基本的复杂度分析还是要有的，不管是在面试中，还是在编码过程，这都体现了你对所写程序在未来运行的预测能力、以及性能优化的定位
+ 但是，多学一些数学还是好的，不仅能提高逻辑思维，还能提高分析和解答算法问题的速度、准确性
:::



## 算法思想

算法思想是及其重要的，数据结构只是用于辅助算法

+ `枚举`：即暴力求解，这个过程往往只使用循环去迭代问题的解，属于最简单且行之有效的方法；但随着问题的复杂化，算法往往变得更为复杂（更多的判断），以及更高的时间/空间渐进复杂度
+ `递归`：只有问题和子问题存在递推关系，就可以使用递归，递归唯一的代价是会使用额外的调用栈空间
+ `回溯法`：
+ `分治法`：使用 “分而治之” 的思想，当问题拆分的子问题的解能反映问题的解时，只要将子问题拆分得足够小，再将子问题合并即可得到问题的解
+ `动态规划`：与分治法类似，都是使用子问题来求解问题（该问题通常为最优解问题），但这个子问题通常是指重叠（重复计算）子问题（而分治法是全新的同类型子问题）；另外，动态规划一般都是通过 “备忘录” 来记录子问题的解，当所有子问题都求解完毕，才开始求解问题，算法实现通常都是`自底向上`的
+ `贪心法`：类似动态规划，都包含`最优子结构性质`（即问题的最优解包含子问题的最优解），但其`贪心选择性质`使它不一定能求解问题最优解（但大多数情况下是最优解）；另外，贪心法一般都是进行了贪心选择后采取求解子问题（动态规划要先求解子问题才做选择），算法实现通常都是`自顶向下`的
+ `分支界限`：
+ `位运算`：程序进行位操作是非常快的，使用位运算（`<<`, `>>`, `>>>`, `~`, `&`, `|`, `^`）能够快速求解问题；最关键的问题在于如何将问题转化为位问题（好像在问：你真的懂 `^` 吗？）


::: tip 备注：
+ 枚举是很重要的，可以说只要有循环就有枚举的存在，它可以帮助我们去分析问题的解，以及如何从当前的解去进行优化
+ 递归是很常用的，很多重要的数据结构(链表、树、图等)或其他算法思想(分治法、动态规划、贪心法)都使用了递归；熟练掌握递归，对深入算法十分有帮助
+ 动态规划属于比较复杂的算法，它和分治法、贪心法都有些类似，所以要明确三者的使用场景
+ 之所以将位运算归纳为算法思想，是因为若问题可转化为 “位” 的操作去求解时，算法复杂度通常可以极大地降低，甚至是常量复杂度
:::



## 算法分类

首先总结常用数据结构的相关算法，剖析其解法及思路：
+ 字符串
+ 数组
+ 链表
+ 栈
+ 队列
+ 哈希表
+ 堆
+ 优先队列
+ 树
  + 二叉树
  + 并查集
  + 树状数组
  + 线段树
+ 图
+ 布隆过滤器


然后是一些分类算法：
+ 排序算法
+ 查找算法
+ 数论算法
+ 位算法
<!-- + 多线程算法 -->


::: tip 备注：
+ 数据结构和算法相辅相成：算法求解的过程通常要使用数据结构的辅助，而数据结构的实现过程也蕴含了众多的算法思想
+ 在我看来，以分类的方式学习算法，有两大优点：
  1. 加深对数据结构的掌握，如其实现方式、使用场景
  2. 更好地磨合数据结构和算法的关系，如在你选择了一个算法后便知道随后需要使用的数据结构，或是在选择一种数据结构后便知道其常用的算法；使分析问题的速度加快以及提高其准确程度
:::




## 怎样高效刷算法

### 算法是可理解的 

+ 转化思想很重要：复杂的问题大多数都是可以转化、拆解为简单的问题的
+ 并列的循环也是可取的：
  + 强行将代码放到一个循环里，有时候代码会十分臃肿而且难以理解
  + 并列循环不会增加太多的时间复杂度，但可以让编程更容易

::: tip 算法主要考察的内容：
+ 数据结构的掌握：知道常用数据结构的特性，时间、空间复杂度
+ 基础算法的掌握、问题的转化：每个算法题都可拆分、转为为基础算法
+ 编码功底：虽然用到的编程语言知识不多，但是编码能力强 = 快速实现想法
:::


### 要量力而为

+ 不是所有算法你都能解出来，积累多了便更容易了；给自己一个时间限制
  + 思想层面：认真思考 30 分钟，思考不出完整解法就去看题解，然后对比自己想到了多少，如 80%，做个标注，下次遇到的时候可以对比一下自己是进步了还是遗忘了
  + 代码层面：认真写代码 30 分钟，不能通过就看题解，对比自己的代码，哪里不行的做个标注，有助于提升自己的代码功底
  + 实在不能理解的题目，收藏起来，等你下次回来看的时候，应该看法就不一样了

+ 先解决问题再去优化：不要一昧地寻求最简单最快的方法，由浅及深更容易理解和学习，多看题解，多做笔记