## 简介

+ 本系列文档的代码使用 `JavaScript` 语言实现，记录了以下内容：
  + 算法分析：算法指标、指标分析方法
  + 算法分类：按算法思想
  + 算法分类：按数据结构
+ 更多题型、解法参考 [LeetCode](https://leetcode-cn.com/)
  + [🔥 LeetCode 热题 HOT 100](https://leetcode-cn.com/problemset/leetcode-hot-100/)
  + [🧡 LeetCode 精选算法 200 题](https://leetcode-cn.com/problemset/leetcode-200/)
  + [👨‍💻 LeetCode 精选 TOP 面试题](https://leetcode-cn.com/problemset/leetcode-top/)


::: tip 备注
+ 学习算法就像学习数学一样，当你掌握了多种算法（类比数学公式），在面对各种题目的时候，若能将问题转化为曾经学过的算法，那么问题的答案就呼之欲出了
+ 许多算法都是有模版的，也就是说考察这些算法的问题比较容易转为，如二分查找、0-1背包、并查集、...
+ 但并不是所有算法都是能够使用模版来代入（背题目是效果极低的做法），模版只是用来方便理解算法，其本质还是要理解算法，以及熟悉各种[数据结构](../data-structures/)
:::



## 算法分析

首先了解衡量算法性能的函数增长记号（平时用的最多的是 $O$ 记号）：
+ $\Theta$：渐近紧确界，渐近给出了函数的上界和下界
+ $O$：渐近上界
+ $\Omega$：渐近下界
+ $o$：非渐近紧确的上界
+ $\omega$：非渐近紧确的下界


再学习从两个方面来衡量算法的性能：

+ 时间复杂度：算法运行至得到结果所需要的时间量度
+ 空间复杂度：算法运行至得到结果所需要额外使用的物理内存

::: tip 备注
空间复杂度是指除程序的返回内容外，额外使用的空间；如算法接受一个数组，要求返回一个全新的等长的数组，该数组空间不会算入空间复杂度
:::


以及更高级的分析技巧 —— 摊还分析：
+ 聚合分析
+ 核算法
+ 势能法
+ 动态表


::: tip 备注：
+ 虽然不必每一步都亲自去证明（建议去做），但是基本的复杂度分析还是要有的，不管是在面试中，还是在编码过程，这都体现了你对所写程序在未来运行的预测能力、以及性能优化的定位
+ 但是，多学一些数学还是好的，不仅能提高逻辑思维，还能提高分析和解答算法问题的速度、准确性
:::



## 算法分类

+ 数据结构和算法相辅相成：算法求解的过程通常要使用数据结构的辅助，而数据结构的实现过程也蕴含了众多的算法思想
+ 数据结构只用于辅助算法，而算法思想是算法的灵魂，一个完整的算法应该是由数据结构和算法思想组成的
+ 在我看来，以分类的方式学习算法，有两大优点：
  1. 加深对数据结构的掌握，如其实现方式、使用场景
  2. 更好地磨合数据结构和算法的关系，如在你选择了一个算法后便知道随后需要使用的数据结构，或是在选择一种数据结构后便知道其常用的算法；使分析问题的速度加快以及提高其准确程度



### 按算法思想


+ `枚举`：即暴力求解，这个过程往往只使用循环去迭代问题的解，属于最简单且行之有效的方法；但随着问题的复杂化，算法往往变得更为复杂（更多的判断），以及更高的时间/空间渐进复杂度
+ `递归`：只有问题和子问题存在递推关系，就可以使用递归，递归唯一的代价是会使用额外的调用栈空间
+ `回溯法`：使用 “剪枝” 的方法减少问题的求解规模，在一定条件下退出当前子问题求解，返回到父问题重新选择
+ `分治法`：使用 “分而治之” 的思想，当问题拆分的子问题的解能反映问题的解时，只要将子问题拆分得足够小，再将子问题合并即可得到问题的解
+ `动态规划`：与分治法类似，都是使用子问题来求解问题（该问题通常为最优解问题），但这个子问题通常是指重叠（重复计算）子问题（而分治法是全新的同类型子问题）；另外，动态规划一般都是通过 “备忘录” 来记录子问题的解，当所有子问题都求解完毕，才开始求解问题，算法实现通常都是`自底向上`的
+ `贪心法`：类似动态规划，都包含`最优子结构性质`（即问题的最优解包含子问题的最优解），但其`贪心选择性质`使它不一定能求解问题最优解（但大多数情况下是最优解）；另外，贪心法一般都是进行了贪心选择后采取求解子问题（动态规划要先求解子问题才做选择），算法实现通常都是`自顶向下`的
+ `位运算`：程序进行位操作是非常快的，使用位运算（`<<`, `>>`, `>>>`, `~`, `&`, `|`, `^`）能够快速求解问题；最关键的问题在于如何将问题转化为位问题
+ `双指针`：包括快慢指针、二分查找、滑动窗口等问题，它们是优化算法时间的好方法
+ `前缀和`：通过统计连续序列的和来优化查询值的时间，是典型的 `空间换时间`
+ `搜索`：分为深度优先搜索(`DFS`)和广度优先搜索(`BFS`)，是非常常用的两种搜索算法
+ `分支界限`：

::: tip 备注：
+ 枚举是很重要的，可以说只要有循环就有枚举的存在，它可以帮助我们去分析问题的解，以及如何从当前的解去进行优化
+ 递归是很常用的，很多重要的数据结构(链表、树、图等)或其他算法思想(回溯法、分治法、动态规划、贪心法)都使用了递归；熟练掌握递归，对深入算法十分有帮助
+ 动态规划属于比较复杂的算法，它和分治法、贪心法都有些类似，所以要明确三者的使用场景
+ 之所以将位运算归纳为算法思想，是因为若问题可转化为 “位” 的操作去求解时，算法复杂度通常可以极大地降低，甚至是常量复杂度
+ 其他有用的思想：
  + 转化思想：复杂的问题大多数都是可以转化、拆解为简单的问题的
  + 拆分循环：强行将代码放到一个循环里，有时候代码会十分臃肿而且难以理解，并列循环不会增加太多的时间复杂度，但可以让编程更容易
:::




### 按数据结构

+ 字符串
+ 数组：$O(1)$ 的存取、设置时间复杂度，$O(n)$ 的删除、插入时间复杂度
+ 链表：$O(n)$ 的存取、设置时间复杂度，$O(1)$ 的删除、插入时间复杂度
  + 循环链表
  + 双向链表
+ 栈
  + 单调栈
+ 队列
  + 单调队列
  + 双端队列
+ 哈希表：$O(1)$ 的存取时间复杂度，$O(n)$ 的空间复杂度
+ 堆 && 优先队列
+ 树：一种特殊的图
  + 二叉树
  + 二叉搜索树
  + 字典树
  + 线段树
  + 树状数组
+ 图
  + 并查集
  + 拓扑排序
  + 最小生成树
+ 布隆过滤器


### 更多分类

+ 排序算法
+ 查找算法
+ 数论算法
<!-- + 多线程算法 -->





## 补充：刷算法的技巧

### 善用 LeetCode

> 由于我本人选择了 LeetCode，所以以 LeetCode 为例

+ 选择编程语言：建议 `C++`/`Java`/`Python` 三选一，主要是性能好、方便（有现成的数据结构、参考代码多）；其次可选择自己的领域语言(本人用 JavaScript)，缺点是一些数据结构需要自动手动实现（堆、优先队列等）
+ 每日一题：坚持签到是好习惯（坚持独立完成、认真看题解而不总是 CV）；坚持练习，总会有游刃有余的一天
+ 题解 && 笔记：毋需多说，多做笔记，如果加上日期的标注，下次再见时，便知道自己是否有所进步
+ 收藏夹：LeetCode 的分类规则可能不适用于每个人，多对题目和知识点分类，汇总重要、高频算法
+ 周赛：不用非得刷到几百题才去竞赛，熟悉数据结构和算法思想，每个类型做了几个题，总量 50 题左右就可以去参赛了；成绩不好不可耻，只有看到了和别人的差距才有更好的动力，同时竞赛也是阶段性测试的一个好手段


### 要量力而为

+ 先解决问题再去优化：不要一昧地寻求最简单最快的方法，由浅及深更容易理解和学习，多看题解，多做笔记
+ 不是所有算法你都能解出来，积累多了便更容易了，要给自己一个时间限制：
  + 思考 15~30 分钟，思考不出完整解法就去看题解，然后对比自己想到了多少，如 80%，做个标注，下次遇到的时候可以对比一下自己是进步了还是遗忘了
  + 代码 15~30 分钟，不能通过就看题解；对比自己的代码，哪里不行的做个标注（能提升代码能力）

::: tip 两种刷题方法：
+ “龟” 法：追求算法深入和理解，适合学生、空闲时间多时
+ “兔” 法：追求量，适合面试期间抱佛脚、阶段性的总结
:::


### 谨慎使用语法糖

> 在题目明文禁止的情况下，我们不能使用库函数

+ 除了库函数外，一些语法糖可能会使算法的性能下降：如 JavaScript 数组的解构赋值
```js
// 解构赋值
let a = 1, b = 2;
[a, b] = [b, a + b];

// 替换为临时变量
let a = 1, b = 2, tmp;
tmp = b;
b = a + b;
a = tmp;

// 由于解构赋值内部使用了 Iterator，导致空间复杂度会增加
// 使用 benchmark 测试：解构赋值方式比临时变量方式慢 30%
```



## 处理输入输出的模板

### 每行为一组数据

+ 适用：每行是一组完整输入，行结束便输出结果
+ 例题：输入 n 行，每行是两个整数，输出它们的和
```
输入：
12 22
1 2
50 100

输出：
34
3
150
```

+ 代码示例

:::: tabs
::: tab JavaScript
+ 借助 `readline` 模块的 `createInterface()`
```js
const r1 = require("readline").createInterface({
  input: process.stdin,
  output: process.stdout
});

r1.on("line", str => {
  const [a, b] = str.split(" ");
  console.log(solution(+a, +b));
});

function solution(a, b) {
  return a + b;
}
```
:::

::: tab Java
+ 使用 `Scanner` 工具类，以及相关方法
```Java
import java.util.*;

public class Main {
  public static void main(String args[]) {
    int a, b;
    Scanner cin = new Scanner(System.in);
    
    while (cin.hasNextInt()) {
      a = cin.nextInt();
      b = cin.nextInt();
      System.out.println(solution(a, b));
    }
  }
  
  public static int solution(int a, int b) {
    return a + b;
  }
}
```
:::

::: tab C++
+ 使用 `<iostream>` 提供的输入输出流
```cpp
#include <iostream>

using namespace std;

int solution(int a, int b);

int main() {
  int a, b;
  cin >> a >> b;
  cout << solution(a, b) << endl;
  return 0;
}

int solution(int a, int b) {
  return a + b;
}
```
:::
::::


### 只包含一组数据

+ 适用：未指定数据行数时
+ 例题：[01背包](https://www.acwing.com/problem/content/2/)，数据的第一行是两个数值，分别为 $N$、$V$，表示物品的个数和背包的容量；紧跟 $N$ 行，每行两个数字分别代表物品的体积 $v_i$、价值 $w_i$。
```
输入：
4 5
1 2
2 4
3 4
4 5

输出：10
其中 N = 4, V = 5, v = [1,2,3,4], w = [2,4,4,5]
```

+ 代码示例：
:::: tabs
::: tab JavaScript
+ `readable` 事件持续读取数据，`end` 事件执行并打印结果
```js
let buf = "";

process.stdin.on("readable", () => {
  const chunk = process.stdin.read();
  if (chunk) buf += chunk.toString();
});

process.stdin.on("end", () => {
  let N, V;
  const v = [];
  const w = [];
  
  buf.split("\n").forEach((line, i) => {
    const [a, b] = line.split(" ");
    if (i === 0) {
      N = +a;
      V = +b;
    } else {
      v.push(+a);
      w.push(+b);
    }
  });
  
  console.log(solution(N, V, v, w));
});

function solution(N, V, v, w) {
  // ...
}
```
:::

::: tab Java
+ 依旧可以使用 `Scanner` 读取
```java
import java.util.*;

public class Main {
  public static void main(String args[]) {
    int n, m;
    int v[] = new int[1005];
    int w[] = new int[1005];
    int i = 1;
    Scanner cin = new Scanner(System.in);

    n = cin.nextInt();
    m = cin.nextInt();
    while (cin.hasNextInt()) {
      v[i] = cin.nextInt();
      w[i] = cin.nextInt();
      i++;
    }
    
    System.out.println(solution(n, m, v, w));
  }
  
  public static int solution(int n, int m, int v[], int w[]) {
    // ...
  }
}
```
:::

::: tab C++
+ `cin` 的功能很强大，既能处理指定行数的输入，也能轻松应付不定行的输入
```cpp
#include <iostream>

using namespace std;

int solution(int, int, int [], int []);

const int LEN = 1005;
int w[LEN];
int v[LEN];

int main() {
  int n, m;
  int i = 1;
  cin >> n >> m;
  while (cin >> v[i] >> w[i]) i++;
  cout << solution(n, m, v, w) << endl;
  return 0;
}

int solution(int n, int m, int v[], int w[]) {
  // ...
}
```
:::
::::