---
sidebarDepth: 2
---

## 基础

+ 位运算操作的是二进制，二进制是计算机最底层的数据结构，因此速度是最快的
+ 编程语言一般会提供两种接口(位运算符、移位运算符)，用于直接操作二进制


### 有符号数和补码

+ 无符号数：如 32 位整数，能表示的数值范围为 0~2^32^
+ 有符号数：如 32 位整数，能表示的数值范围为 -2^31^~2^31^-1，这是因为其二进制最高位为符号位(1 表示负数)
+ 补码：有符号数的主要实现方式

::: tip 备注
+ 目前除了 C/C++ 外基本所有语言都只使用有符号数字
+ javascript 使用的是 64 位双精度浮点数，而且只支持 32 位整数的位运算
:::






## 位操作符

### 简介

+ 一般编程语言均支持的位运算符：
  + `~`：非，将操作数的各个二进制位取相反值(原来为 0 则变为 1，反之)
  + `&`：与，从低位开始按位比较二进制值，两者都为 1 时，结果为 1，否则为 0
  + `|`：或，从低位开始按位比较二进制值，两者任一为 1 时，结果为 1，否则为 0
  + `^`：异或，从低位开始按位比较二进制值，两者不同时，结果为 1，否则为 0

+ 对比：

|位运算符|操作数1|操作数2|结果|
|-|-|-|-|
|`~`|10001111(79)|-|0111000()|
|`&`|10001111(79)|11110011(243)|10000011(67)|
|`|`|10001111(79)|11110011(243)|11111111(255)|
|`^`|10001111(79)|11110011(243)|01111100(188)|

+ 运算过程
```js
/* ~
  ~10001111 => 79
   --------
   01110000 => 
*/

/* &
    10001111 => 79
  & 11110011 => 243
  ----------
    10000011 => 67
*/

/* |
    10001111 => 79
  | 11110011 => 243
  ----------
    11111111 => 255
*/

/* ^
    10001111 => 79
  ^ 11110011 => 243
  ----------
    01111100 => 188
*/
```


### 按位非

+ `~num` 相当于 `-num-1`
```js
const num = 12
console.log(~num === -num-1)   // true

// 封装成一个谓词函数
const opposite = num => ~num + 1
```


### 按位且

+ 判断奇偶性
```js
if (a % 2 === 0) {
  // 是偶数
}

if (a & 1 === 0) {
  // 是偶数
}
```

::: tip 说明：
+ `a & 1` 可以理解为判断二进制的最低位是否是 1，而这于奇偶性是一致的
+ 如果能理解 `a & 0` 恒等于 0，那么 `a & 1` 就容易理解了
```js
/* 二进制位标记为 x，表示它可以为 1 或 0
a & 0:
    xxxxxxxx => a
  & 00000000 => 0
  ----------
    00000000 => 0

a & 1:
    xxxxxxx1 => 奇数 a
  & 00000001 => 1
  ----------
    00000001 => 1

    xxxxxxx0 => 偶数 a
  & 00000001 => 1
  ----------
    00000000 => 0
*/
```
:::


### 按位异或

+ 对于任何数，`a ^ 0 === a`
+ 对于任何数，`a ^ a === 0`，可以用于判断两数是否相等：
```js
if (a === b) {
  // 两数相等
}

if (!(a ^ b)) {
  // 两数相等
}
```

::: tip 备注：
+ `a ^ a === 0` 是一种抵消的思想，因此在一些算法问题中，用处非常大
+ `^` 是非常巧妙的一种运算，联合其他位运算符可以实现非常复杂的功能
:::




## 移位运算符

### 简介

+ 一般编程语言均支持的移位运算符：
  + `<<`：左移，将操作数的所有二进制位向左移动指定位数，右侧空位以 0 补充
  + `>>`：有符号右移，将操作数的所有二进制位想右移动指定位数，左侧空位以符号位补充
  + `>>>`：无符号右移，将操作数的所有二进制位向右移动指定位数，左侧空位以 0 补充

::: tip 备注
+ 使用移位需要考虑溢出，如在有符号数中使用，有可能会在正负数之间切换
:::


### 左移

+ 使用 `<<` 让一个数字翻倍(无溢出时)
```js
a = 1
a = a * 2   // 常规写法
a = a << 1  // 左移写法

// 左移更快也更优雅：如需要将翻倍的操作重复 5 次
a = a * Math.pow(2, 5)  // 常规写法
a = a << 5              // 左移写法
```



### 有符号右移

+ 类比 `>>`，但该操作是不精确的，对奇数使用时会丢失精度，结果不是除以 2，而是 `Math.floor(a/2)`
```js
16 >> 1   // 8
15 >> 1   // 7

-16 >> 1  // -8
-15 >> 1  // -8
```

+ 可以用于判断一个数是否是负数
```js
/* 
  原理：使用补码的有符号数最高位标识数字的正负，0 为非负数，只需要校对最高位的值即可
  对于不同位数的数值有符号右移的位数不同，如 32 位整数为 num >> 31
*/
const isPositive = num => num === 0 ? false : ((num >> 31) & 1 === 0)
```


### 无符号右移





## Todos

实现四则运算：
+ 全加器
+ 乘法



## 基本操作

### 是否是 2 的幂

+ 判断是否是 2 的 n 次幂，即 a = 2^n^
```js
const isPowerOf2 = a => a > 0 && (a & (a - 1)) === 0

// 若不使用位运算，可能需要更多更复杂的操作
```

::: tip 说明：
+ 我们知道位运算的减法：00010000(16) - 1 => 00001111(15)，那么，规律显而易见：
```js
/*         2        4        8       16       32       64      128
    00000010 00000100 00001000 00010000 00100000 01000000 10000000
-1  00000001 00000011 00000111 00001111 00011111 00111111 01111111
  & --------------------------------------------------------------
    00000000 00000000 00000000 00000000 00000000 00000000 00000000
*/
```
:::


+ 问题扩展：是否是 4 的 n 次幂，即 a = 4^n^



### 二进制位上 1 的个数

+ 问题：判断一个数字的二进制位上有多少个 1，如 51(00110011) 包含 4 个 1
```js
// 方法1：使用 a&(a-1)
const countOf1 = a => {
  let count = 0

  while (a) {       // 当 a !== 0 时
    a &= a - 1      // 消去一个较低位的 1
    count++         
  }

  return count
}

// 方法2：使用无符号右移
const countOf1 = a => {
  let count = 0

  while (a) {       // 当 a !== 0 时
    count += a & 1  // 判断最低位是否是 1
    a >>>= 1        // 对于最低位：用完即弃，不关心精度
  }

  return count
}
```


### 要修改的二进制位数

+ 问题：当一个数字 a 变为另一个数字 b 时，需要修改多少个二进制位完成改变？
```js
/* 如 00110011 => 11001100，需要改变的二进制位数为 8
  为什么是这样呢？因为对于二进制值相同的位不需要改变，不同的才需要改变
  这非常符合 `^` 运算符的定义：
    00110011
  ^ 11001100
  ----------
    11111111 => 所有位都不同，因此都需要改变
  
  再看：
    11001001
  ^ 10001011
  ----------
    01000010 => 只有两个位不同，只需要改变 2 个位
  
  OK！问题现在转为为：求 (a^b) 的二进制位上 1 的个数，很熟悉是吧？
*/

const bitsDiff = (a, b) => countOf1(a ^ b)
```


### 有效二进制位数

+ 返回一个数字的有效二进制位数，即去除所有前缀 0，如 00010000(16) 的有效位数为 5
```js
const bitLength = num => {
  let len = 0

  while ((1 << len) <= num) {
    len++
  }

  return len
}
```


### 获取/设置二进制位

+ 获取数字的某个二进制位的值(从最低位开始)，如 51(00110011) 的第 5 位为 1
```js
const getBit = (a, order) => (a >> order) & 1
```

+ 将数字的某个二进制位设为 1/0，如将 11110000(240) 的第四位(从低位开始)设为 1/0
```js
// 设置为 1
const setBit = (num, bitPosition) => num | (1 << bitPosition)

// 设置为 0
const clearBit = (num, bitPosition) => num & (~(1 << bitPosition))

// 合并上述两个操作
const updateBit = (num, bitPosition, bitValue) => {
  const bitValueNormalized = bitValue ? 1 : 0
  const clearMask = ~(1 << bitPosition)
  // 先清除指定位的值，再使用 | 设置新值
  return (num & clearMask) | (bitValueNormalized << bitPosition)
}
```




## 经典题目

### 只出现一次的数字

+ 问题1：一个数组中除了一个数字只出现一次外，其他均出现偶数次，找出只出现一次的数字
```js
/* 如: [12, 12, 11, 2, 2, 2, 2] => 11
   结合以下两点，我们就能写出问题解法：
   1. a^a === 0，a^0 === a
   2. 多个 ^ 之间不区分执行顺序

   也就是说，只要对数组的所有数字按顺序执行 ^ 操作，就能得到结果了！
*/

// 偷懒写法
const findOne = arr => eval(arr.join('^'))
const findOne = arr => arr.reduce((a, b) => a^b)

// 常规写法
const findOne = arr => {
  let i = arr.length - 1
  let ret = 0

  while (i >= 0) {
    ret ^= arr[i--]
  }

  return ret
}
```
