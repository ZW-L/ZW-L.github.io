---
sidebarDepth: 2
---

## 简介

+ 递归(recursion)是指一个函数在其内部调用自身
+ 递归是计算机常用的概念，在计算机的角度，递归是容易理解的
+ 迭代是人，递归是神


::: tip 备注：
+ 函数的执行机制和调用栈：在函数内部执行，若遇到另一个函数时，会先将当前函数的执行环境推入一个栈(调用栈)中，然后先去执行遇到的函数
+ 栈大小：在递归中，执行栈通常是非常深的，而程序可用的栈空间是固定的
:::


### 要素

1. 开始：简单来说，就是在函数内部调用自身
3. 结束：递归必须退出，否则会出现栈溢出(`Maximum call stack size exceeded`)


### 优化  

+ 尾递归：递归会重复计算已计算的工作，使用额外的参数将
+ 改用栈：若不支持尾递归，可以使用栈实现递归(递归和栈是可以相互转换的，但是空间复杂度差不多)
+ 改用循环：循环可以减少空间复杂度，但是有可能会增加时间复杂度


### 何时使用

+ 判断递归（推）公式：递归必定存在一个递归（推）公式，它是使用递归的关键


::: tip 备注：
+ 递归公式属于特殊的递推公式，百度百科定义的递归公式：递推式只包含数列中的项而无常数项或其它项
+ 虽然递归和递推是不一样的，但是一般来说，只要有了递推公式就能写出一个递归，原因是：`递归和递推是可以相互转化的`
+ 递归公式也可以进步一化简成为解的通项公式，这样问题的复杂度就降至最低了
:::




## 从简单的递归说起

### 阶乘

:::: tabs
::: tab 问题描述
+ 递推公式：

$$
f(n) = 
  \begin{cases}
    1,              & n = 1 \\ 
    n * f(n - 1),   & n\geq2
  \end{cases}
$$
:::

::: tab 递归实现
+ 根据递推公式很容易写出：
```js
function factorial (n) {
  // 退出递归
  if (n === 1) return 1
  return n * factorial(n - 1)
}

factorial(5)  // 120
factorial(10) // 3628800
factorial(30) // 9.33262154439441e+157
```
+ 该案例没有涉及到重复计算的情况，以 `3!` 为例，执行过程如下：
```sh
    3!
  /   \
  3    2!     # 每层递归函数都保留了当前的 n 值
      /  \ 
    2    1!  # 最终结果只会计算 factorial(1)，然后递归回升
           \
            1
```
:::
::::



### 斐波那契数列

:::: tabs
::: tab 问题描述
+ 问题描述：形如 `0 1 1 2 3 5 8 13 21 34 55 ...` 的数列，n 表示数列的第 n 项，设计函数求取第 n 项
+ 递推公式：
$$
f(n) = 
  \begin{cases}
    0,                     & n = 0 \\
    1,                     & n = 1 \\
    f(n - 1) + f(n - 2),   & n\geq2
  \end{cases}
$$
:::

::: tab 递归实现
+ 根据递归公式很容易写出代码：
```js
function fibonacci (n) {
  // 退出递归
  if (n === 1) return 0
  if (n === 2) return 1
  return fibonacci(n - 1) + fibonacci(n - 2)
}

// 测试结果：会发现 n 值稍大(>30)时，代码的执行速度明显下降
fibonacci(5)   // 3
fibonacci(10)  // 34
fibonacci(30)  // 514229
```

+ 执行过程：过程重复计算已计算过的值
```sh
            f(5)
          /      \
        f(4)     f(3)     # f(4) 已经计算过 f(3)，但是执行至右侧，还是会重复计算
       /   \     /  \
    f(3) f(2)  f(2) f(1)  # 同理，f(2) 和 f(1) 也重复执行了多次
    /  \
  f(2) f(1)
```
:::

::: tab 尾递归优化
+ 尾递归
```js
function fibonacci (n, a1 = 0, a2 = 1) {
  // 退出递归
  if (n === 1) return a1
  return fibonacci(n - 1, a2, a1 + a2)
}
```

+ 执行过程：每个函数调用栈都额外保存两个变量
```sh
       f(5)
     /  |  \
    0   1   f(4)
           / | \
          1  1  f(3)
               / |  \
              1  2  f(2)
                   / | \
                  2  3  f(1)
                       / | \
                      3  5  done  # 最终返回 f(5) = 3
```
::: 

::: tab 循环实现
+ 若难以进行尾递归优化，使用循环是个简单的方法：
```js
function fibonacci (n) {
  let a1 = 0, a2 = 1
  while (n > 1) {
    [a1, a2] = [a2, a1 + a2]
    n--
  }
  return a1
}
```
:::
::::

::: tip 备注：
+ 尾递归优化主要是：减少函数的重复调用(不重复计算子问题)，类似动态规划中的 “备忘录方法”
+ 尾递归优化时，只会创建**常数级别**的调用栈，递归触底回升过程中逐步清空调用栈，直接返回结果
+ 无尾递归优化时，调用栈是**指数级别**的，因此容易栈溢出；即使栈没有溢出，左侧递归回升过程中总会等待右侧递归回升，而他们的大部分计算都是重复的
:::



## 经典问题

### 汉诺塔


:::: tabs
::: tab 问题描述和解析
+ 问题描述：有三个圆柱(a, b, c)，其中 a 柱上套了三个圆盘(1, 2, 3)，其中最小的在最上面，依次层叠；现将 a 柱的三个圆盘转移到 c 柱上，并且规定较小的圆盘上方不能放大于它的圆盘，以下是操作的过程，每移动一个圆盘算依次操作，问若将 n 个圆盘移动到 c 柱，至少需要移动多少次？
+ 过程分析
```sh
       1     
       2                           2
       3                           3             1
开始  -----   -----   -----   =>  -----  -----  -----
       a       b       c           a      b      c

            
                                          1
       3       2       1           3      2      
=>   -----   -----   -----   =>  -----  -----  -----
       a       b       c           a      b      c

               1                          
               2       3           1      2      3
=>   -----   -----   -----   =>  -----  -----  -----
       a       b       c           a      b      c

                                                 1
                       2                         2
       1               3                         3
=>   -----   -----   -----   =>  -----  -----  -----  => 结束
       a       b       c           a      b      c
```
+ 观察移动 3 个圆盘时，虽然经历了 7 次移动，但是将整个过程归纳为 3 个子过程：
  1. 将 1,2 圆盘移动到 b
  2. 将 3 圆盘移动到 c
  3. 将 1,2 圆盘移动到 c

+ 推广到 n 个圆盘，也是同样的子过程：
  1. 将 1~n-1 圆盘移动到 b
  2. 将 n 圆盘移动到 c
  3. 将 1~n-1 圆盘移动到 c

+ 验证过程的正确性：主要验证步骤 1、3 是否能够完成
  + 假设汉诺塔问题是能够完成的（当然，我不会去证明），那么步骤 1、2 必定能完成
  + 执行步骤 2 后，c 柱放置了最大的圆盘，因此 c 柱仍可以作为辅助(暂时存放圆盘)，故步骤 3 能完成

+ 推导递推公式：步骤 1、3 的操作次数都是 $f(n-1)$，步骤 2 的次数为 1，递推公式为：
$$
f(n) = 2 * f(n-1) + 1
$$

+ 递归公式可以继续推导为通项公式：
$$
f(n) = 2*f(n-1)+1 = 2^n-1
$$
:::

::: tab 代码实现
+ 根据递推公式很容易写出：
```js
function hanoi (n) {
  // 递归退出
  if (n === 1) return 1
  return 2 * hanoi(n - 1) + 1
}

console.log(hanoi(3))   // 7
console.log(hanoi(10))  // 1023
console.log(hanoi(20))  // 1048575
```

+ 使用最终推导的通项公式：
```js
function hanoi (n) {
  // return 2 ** n - 1
  return (1 << n) - 1
}

console.log(hanoi(3))   // 7
console.log(hanoi(10))  // 1023
console.log(hanoi(20))  // 1048575
```
:::
::::
