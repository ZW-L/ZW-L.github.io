---
sidebarDepth: 2
---

## 概念

### 简介

+ **贪心算法**在每一步都做出当时看起来是最佳的选择，也就是说，它总是做出局部最优的选择，寄希望这样的选择能导致全局最优解
+ 通常都是自顶向下的设计：
  + **是**做出一个选择，然后求解剩下的那个子问题
  + **而不是**自底向上地求解出很多子问题，然后再做出选择


::: tip 备注：
+ 贪心算法并不保证得到最优解，但对很多问题确实可以求到最优解
+ 在每个贪心算法之下，几乎总有一个更繁琐的动态规划算法
:::


### 算法设计步骤

1. 转化最优化问题：对其做出一次选择后，只剩下一个子问题需要求解
2. 证明：最初贪心选择后，原问题总是存在最优解，即贪心算法总是安全的
3. 证明：做出贪心选择后，剩余的子问题满足性质 —— 其最优解与贪心选择组合即可得到原问题的最优解，这样就得到了最优子结构


### 两个性质

1. 贪心选择性质：可以通过做出局部最优(贪心)选择来构造全局最优解
2. 最优子结构性质：该问题的最优解包含其子问题的最优解


::: tip 提示：
+ 若进行贪心选择时不得不考虑众多条件，通常意味着可以改进贪心选择，使其更为高效
+ 对输入进行预处理或者使用合适的数据结构(通常是优先队列)，可以使贪心选择更快速，得到更高效的算法
:::


::: tip 对比动态规划：
+ 相同点：都包含最优子结构性质，这是**使用动态规划和贪心算法的关键要素**
+ 不同点：
  + 动态规划通常以**自底向上的方式**求解，即先求解较小的子问题，然后是较大的子问题；而贪心算法通常是通过**自顶向下的方式**进行一次又一次的选择，将给定问题实例变得更小
  + 动态规划**依赖子问题**，要先求解子问题才能进行第一次选择；而贪心算法**不依赖子问题或将来的选择**(但可能依赖之前的选择)，在进行第一次选择前不求解任何子问题
+ 可以用 **0-1 背包问题**和**分数背包问题**区分二者：贪心算法可以解决分数背包问题，但不能解决 0-1 背包问题
:::





## 问题

### 活动选择

:::: tabs
::: tab 伪代码
截图
:::

::: tab javascript
```js
/**
 * 贪心法解活动选择问题
 * @param {array} s - 活动开始时间的数组
 * @param {[]} f - 活动结束时间的数组
 * @returns {[[]]} - 包含活动列表的二维数组
 */
function greedyActivitySelector(s, f) {
  let k = 0
  let res = [[s[0], f[0]]]

  for (let i = 1, len = s.length; i < len; i++) {
    if (s[i] >= f[k]) {
      res.push([s[i], f[i]])
      k = i
    }
  }

  return res
}

const s = [1, 3, 0, 5, 3, 5, 6, 8, 8, 2, 12]
const f = [4, 5, 6, 7, 9, 9, 10, 11, 12, 14, 16]
console.log(greedyActivitySelector(s, f))
// [[ 1, 4 ], [ 5, 7 ], [ 8, 11 ], [ 12, 16 ]]
```
:::
::::



### 赫夫曼编码

:::: tabs
::: tab 伪代码
```

```
:::

::: tab javascript
```js

```
:::
::::



### 分数背包

:::: tabs
::: tab 伪代码
```

```
:::

::: tab javascript
```js

```
:::
::::
