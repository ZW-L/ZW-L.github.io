---
sidebarDepth: 2
---

## 简介

+ 递归(recursion)是指一个函数在其内部调用自身
+ 函数的执行机制和调用栈：在函数内部执行，若遇到另一个函数时，会先将当前函数的执行环境推入一个栈(调用栈)中，然后先去执行遇到的函数；而在递归中，执行栈通常是非常深的

+ 递归的三要素：
  1. 开始：简单来说，就是在函数内部调用自身
  2. 延续：类似循环不变式，即保证递归从开始到退出的过程是连续的(不会遗漏 case)
  3. 退出：递归必须退出，否则会出现栈溢出(`Maximum call stack size exceeded`)

+ 递归的优化：
  + 尾递归：递归会重复计算已计算的工作，使用额外的参数将
  + 改用栈：若不支持尾递归，可以使用栈实现递归(递归和栈是可以相互转换的，但是空间复杂度差不多)
  + 改用循环：循环可以减少空间复杂度，但是有可能会增加时间复杂度



## 从简单的递归说起

### 阶乘

+ 递归公式：`n! = n * (n-1) * (n-2) * ... * 2 * 1` => `n! = n * (n-1)!`
+ 退出条件：`n === 1`
+ 代码实现：
```js
/**
 * 计算整数的阶乘
 * @param {number} n
 * @returns {number}
 */
function factorial (n) {
  // 退出递归
  if (n === 1) return 1
  return n * factorial(n - 1)
}
```

+ 代码只有两行，很简单是吧！可以先测试结果是否正确：
```js
factorial(5)  // 120
factorial(10) // 3628800
factorial(30) // 9.33262154439441e+157
```

+ 该案例没有涉及到重复计算的情况，以 `3!` 为例，执行过程如下：
```sh
    3!
  /   \
  3    2!     # 每层递归函数都保留了当前的 n 值
      /  \ 
    2    1!  # 最终结果只会计算 factorial(1)，然后递归回升
           \
            1
```


### 斐波那契数列

+ 斐波那契数列：形如 `0 1 1 2 3 5 8 13 21 34 55 ...` 的数列
+ 递归公式：**a~n~ = a~n-1~ + a~n-2~**
+ 退出条件：`n === 1` / `n === 2`
+ 代码实现：
```js
/**
 * 计算指定项的斐波那契数列
 * @param {number} n 需要计算的第几项
 * @returns {number}
 */
function fibonacci (n) {
  // 退出递归
  if (n === 1) return 0
  if (n === 2) return 1
  return fibonacci(n - 1) + fibonacci(n - 2)
}
```

+ 同样，测试一下结果：会发现 n 值稍大(>30)时，代码的执行速度明显下降
```js
fibonacci(5)   // 3
fibonacci(10)  // 34
fibonacci(30)  // 514229
```

+ **普通递归的执行过程**：
```sh
            f(5)
          /      \
        f(4)     f(3)     # f(4) 已经计算过 f(3)，但是执行至右侧，还是会重复计算
       /   \     /  \
    f(3) f(2)  f(2) f(1)  # 同理，f(2) 和 f(1) 也重复执行了多次
    /  \
  f(2) f(1)
```

+ 接下来，使用 `尾递归` 来优化递归：
```js
function fibonacci (n, a1 = 0, a2 = 1) {
  // 退出递归
  if (n === 1) return a1
  return fibonacci(n - 1, a2, a1 + a2)
}
```

+ **尾递归优化后的执行过程**：每个函数调用栈都额外保存两个变量
```sh
       f(5)
     /  |  \
    0   1   f(4)
           / | \
          1  1  f(3)
               / |  \
              1  2  f(2)
                   / | \
                  2  3  f(1)
                       / | \
                      3  5  done  # 最终返回 f(5) = 3
```

::: tip 备注：
+ 可见，尾递归的优化主要作用是：减少函数的重复调用(不重复计算)
+ 尾递归优化时，只会创建**常数级别**的调用栈，递归触底回升过程中逐步清空调用栈，直接返回结果
+ 无尾递归优化时，调用栈是**指数级别**的，因此容易栈溢出；即使栈没有溢出，左侧递归回升过程中总会等待右侧递归回升，而他们的大部分计算都是重复的
+ 最后，若难以进行尾递归优化，老老实实使用循环：
```js
function fibonacci (n) {
  let a1 = 0, a2 = 1
  while (n-- > 1) {
    [a1, a2] = [a2, a1 + a2]
  }
  return a1
}
```
:::



## 经典问题

### 汉诺塔

+ **问题描述**：有三个圆柱(a, b, c)，其中 a 柱上套了三个圆盘(1, 2, 3)，其中最小的在最上面，依次层叠；现将 a 柱的三个圆盘转移到 c 柱上，并且规定较小的圆盘上方不能放大于它的圆盘，以下是操作的过程，每移动一个圆盘算依次操作，问若将 n 个圆盘移动到 c 柱，至少需要移动多少次？

::: details 3 个圆盘时的操作过程：至少移动 7 次
```sh
       1     
       2                           2
       3                           3             1
开始  -----   -----   -----   =>  -----  -----  -----
       a       b       c           a      b      c

            
                                          1
       3       2       1           3      2      
=>   -----   -----   -----   =>  -----  -----  -----
       a       b       c           a      b      c

               1                          
               2       3           1      2      3
=>   -----   -----   -----   =>  -----  -----  -----
       a       b       c           a      b      c

                                                 1
                       2                         2
       1               3                         3
=>   -----   -----   -----   =>  -----  -----  -----  => 结束
       a       b       c           a      b      c
```
:::

::: details 问题解析
+ 观察移动 3 个圆盘时，虽然经历了 7 次移动，但是将整个过程归纳为 3 个子过程：
  1. 将 1,2 圆盘移动到 b
  2. 将 3 圆盘移动到 c
  3. 将 1,2 圆盘移动到 c

+ 推广到 n 个圆盘，也是同样的子过程：
  1. 将 1~n-1 圆盘移动到 b
  2. 将 n 圆盘移动到 c
  3. 将 1~n-1 圆盘移动到 c

+ 验证过程的正确性：主要验证步骤 1、3 是否能够完成
  + 假设汉诺塔问题是能够完成的（当然，我不会去证明），那么步骤 1、2 必定能完成
  + 执行步骤 2 后，c 柱放置了最大的圆盘，因此 c 柱仍可以作为辅助(暂时存放圆盘)，故步骤 3 能完成

+ 递归公式的推导：由上可知，步骤 1、3 的操作次数是一样的，都是 `f(n-1)`，步骤 2 的次数为 1，因此递归公式为：`f(n) = 2 * f(n-1) + 1`
:::

+ 递归公式：`f(n) = 2 * f(n-1) + 1`
+ 退出条件：`n === 1`
+ 代码实现：
```js
function hanoi (n) {
  if (n === 1) return 1
  return 2 * hanoi(n - 1) + 1
}

console.log(hanoi(3))   // 7
console.log(hanoi(10))  // 1023
console.log(hanoi(20))  // 1048575
```

+ 当然，递归公式可以继续推导：`f(n) = 2 * f(n-1) + 1` = 2^n^-1
```js
function hanoi (n) {
  // return 2 ** n - 1
  return (1 << n) - 1
}

console.log(hanoi(3))   // 7
console.log(hanoi(10))  // 1023
console.log(hanoi(20))  // 1048575
```
