---
sidebarDepth: 2
---

## 基础

+ 位运算操作的是二进制，二进制是计算机最底层的数据结构，因此速度是最快的
+ 编程语言一般会提供两种接口，用于直接操作二进制：

  + 位运算符：
    + `~`：非，将操作数的各个二进制位取相反值(原来为 0 则变为 1，反之)
    + `&`：与，从低位开始按位比较二进制值，两者都为 1 时，结果为 1，否则为 0
    + `|`：或，从低位开始按位比较二进制值，两者任一为 1 时，结果为 1，否则为 0
    + `^`：异或，从低位开始按位比较二进制值，两者不同时，结果为 1，否则为 0

  + 移位运算符：
    + `<<`：左移，将操作数的所有二进制位向左移动指定位数，右侧空位以 0 补充
    + `>>`：有符号右移，将操作数的所有二进制位想右移动指定位数，左侧空位以符号位补充
    + `>>>`：无符号右移，将操作数的所有二进制位向右移动指定位数，左侧空位以 0 补充


### 位运算符

+ 对比：

|位运算符|操作数1|操作数2|结果|
|-|-|-|-|
|`~`|10001111(79)|-|0111000()|
|`&`|10001111(79)|11110011(243)|10000011(67)|
|`|`|10001111(79)|11110011(243)|11111111(255)|
|`^`|10001111(79)|11110011(243)|01111100(188)|


+ 运算过程
```js
/* ~
  ~10001111 => 79
   --------
   01110000 => 
*/

/* &
    10001111 => 79
  & 11110011 => 243
  ----------
    10000011 => 67
*/

/* |
    10001111 => 79
  | 11110011 => 243
  ----------
    11111111 => 255
*/

/* ^
    10001111 => 79
  ^ 11110011 => 243
  ----------
    01111100 => 188
*/
```


### 移位运算符





## 位操作符

### 按位且

+ 判断奇偶性
```js
if (a % 2 === 0) {
  // 是偶数
}

if (a & 1 === 0) {
  // 是偶数
}
```

::: tip 说明：
+ `a & 1` 可以理解为判断二进制的最低位是否是 1，而这于奇偶性是一致的
+ 如果能理解 `a & 0` 恒等于 0，那么 `a & 1` 就容易理解了
```js
/* 二进制位标记为 x，表示它可以为 1 或 0
a & 0:
    xxxxxxxx => a
  & 00000000 => 0
  ----------
    00000000 => 0

a & 1:
    xxxxxxx1 => 奇数 a
  & 00000001 => 1
  ----------
    00000001 => 1

    xxxxxxx0 => 偶数 a
  & 00000001 => 1
  ----------
    00000000 => 0
*/
```
:::


+ 判断是否是 2 的 n 次幂，即 `a === Math.pow(2, n)`
```js
const isPowerOf2 = a => (a & (a - 1)) === 0

// 若不使用位运算，可能需要更多更复杂的操作
```

::: tip 说明：
+ 我们知道位运算的减法：00010000(16) - 1 => 00001111(15)，那么，规律显而易见：
```js
/*         2        4        8       16       32       64      128
    00000010 00000100 00001000 00010000 00100000 01000000 10000000
-1  00000001 00000011 00000111 00001111 00011111 00111111 01111111
  & --------------------------------------------------------------
    00000000 00000000 00000000 00000000 00000000 00000000 00000000
*/
```
:::


### 按位异或

+ 对于任何数，`a ^ 0 === a` 恒成立
+ 对于任何数，`a ^ a === 0` 恒成立，可以用于判断两数是否相等：
```js
if (a === b) {
  // 两数相等
}

if (!(a ^ b)) {
  // 两数相等
}
```

::: tip 备注：
+ `a ^ a === 0` 是一种抵消的思想，因此在一些算法问题中，用处非常大
:::


+ 问题：当一个数字 a 变为另一个数字 b 时，需要修改多少个二进制位完成改变？
```js
/* 如 00110011 => 11001100，需要改变的二进制位数为 8
  为什么是这样呢？因为对于二进制值相同的位不需要改变，不同的才需要改变
  这非常符合 `^` 运算符的定义：
    00110011
  ^ 11001100
  ----------
    11111111 => 所有位都不同，因此都需要改变
  
  再看：
    11001001
  ^ 10001011
  ----------
    01000010 => 只有两个位不同，只需要改变 2 个位
  
  OK！问题现在转为为：求 (a^b) 的二进制位上 1 的个数，很熟悉是吧？
*/

const bitsDiff = (a, b) => countOf1(a ^ b)
```

> `countOf1()` 见下文[有符号右移](#有符号右移)


+ 问题：一个数组中除了一个数字只出现一次外，其他均出现偶数次，找出只出现一次的数字
```js
/* 如: [12, 12, 11, 2, 2, 2, 2] => 11
   结合以下两点，我们就能写出问题解法：
   1. a^a === 0，a^0 === a
   2. 多个 ^ 之间不区分执行顺序

   也就是说，只要对数组的所有数字按顺序执行 ^ 操作，就能得到结果了！
*/

// 偷懒写法
const findOne = arr => eval(arr.join('^'))
const findOne = arr => arr.reduce((a, b) => a^b)

// 常规写法
const findOne = arr => {
  let i = arr.length - 1
  let ret = 0

  while (i >= 0) {
    ret ^= arr[i--]
  }

  return ret
}
```






## 移位运算符

### 符号位




### 左移

+ 使用 `<<` 让一个数字翻倍
```js
a = 1
a = a * 2   // 常规写法
a = a << 1  // 左移写法

// 左移更快也更优雅：如需要将翻倍的操作重复 5 次
a = a * Math.pow(2, 5)  // 常规写法
a = a << 5              // 左移写法
```

::: tip 备注：
+ 由于左移(`<<`)操作不会影响符号位，因此左移移位总是等于原数乘以 2
+ 当然，溢出是所有数值运算都会出现的问题，需要独自考虑
:::

+ 问题：返回一个数字的有效二进制位数，即去除所有前缀 0，如 00010000(16) 的有效位数为 5
```js

```



### 有符号右移

+ 类比 `>>`，该操作是不安全的，因为对奇数使用时会丢失精度，因此结果不是除以 2，而是 `Math.floor(a/2)`
```js
16 >> 1   // 8
15 >> 1   // 7
```

+ `>>` 的特性使它在不关心精度的情况下十分有用(方便)
+ 问题：判断一个数字的二进制位上有多少个 1，如 51(00110011) 包含 4 个 1
```js
const countOf1 = a => {
  let count = 0

  while (a) {       // 当 a !== 0 时
    count += a & 1  // 判断最低位是否是 1
    a >>= 1         // 对于最低位：用完即弃，不关心精度
  }

  return count
}
```

+ 问题：获取数字的某个二进制位的值(从最低位开始)，如 51(00110011) 的第 5 位为 1
```js
const getBit = (a, order) => (a >> order) & 1
```




### 无符号右移


