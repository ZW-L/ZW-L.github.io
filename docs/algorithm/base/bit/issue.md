---
sidebarDepth: 2
---

## 基本操作

### 是否是 2 的幂

+ 判断是否是 2 的 n 次幂，即 a = 2^n^
```js
const isPowerOf2 = a => a > 0 && (a & (a - 1)) === 0

// 若不使用位运算，可能需要更多更复杂的操作
```

::: tip 说明：
+ 我们知道位运算的减法：00010000(16) - 1 => 00001111(15)，那么，规律显而易见：
```js
/*         2        4        8       16       32       64      128
    00000010 00000100 00001000 00010000 00100000 01000000 10000000
-1  00000001 00000011 00000111 00001111 00011111 00111111 01111111
  & --------------------------------------------------------------
    00000000 00000000 00000000 00000000 00000000 00000000 00000000
*/
```
:::


+ 问题扩展：是否是 4 的 n 次幂，即 a = 4^n^



### 二进制位上 1 的个数

+ 问题：判断一个数字的二进制位上有多少个 1，如 51(00110011) 包含 4 个 1
```js
// 方法1：使用 a&(a-1)
const countOf1 = a => {
  let count = 0

  while (a) {       // 当 a !== 0 时
    a &= a - 1      // 消去一个较低位的 1
    count++         
  }

  return count
}

// 方法2：使用无符号右移
const countOf1 = a => {
  let count = 0

  while (a) {       // 当 a !== 0 时
    count += a & 1  // 判断最低位是否是 1
    a >>>= 1        // 对于最低位：用完即弃，不关心精度
  }

  return count
}
```


### 要修改的二进制位数

+ 问题：当一个数字 a 变为另一个数字 b 时，需要修改多少个二进制位完成改变？
```js
/* 如 00110011 => 11001100，需要改变的二进制位数为 8
  为什么是这样呢？因为对于二进制值相同的位不需要改变，不同的才需要改变
  这非常符合 `^` 运算符的定义：
    00110011
  ^ 11001100
  ----------
    11111111 => 所有位都不同，因此都需要改变
  
  再看：
    11001001
  ^ 10001011
  ----------
    01000010 => 只有两个位不同，只需要改变 2 个位
  
  OK！问题现在转为为：求 (a^b) 的二进制位上 1 的个数，很熟悉是吧？
*/

const bitsDiff = (a, b) => countOf1(a ^ b)
```


### 有效二进制位数

+ 返回一个数字的有效二进制位数，即去除所有前缀 0，如 00010000(16) 的有效位数为 5
```js
const bitLength = num => {
  let len = 0

  while ((1 << len) <= num) {
    len++
  }

  return len
}
```


### 获取/设置二进制位

+ 获取数字的某个二进制位的值(从最低位开始)，如 51(00110011) 的第 5 位为 1
```js
const getBit = (a, order) => (a >> order) & 1
```

+ 将数字的某个二进制位设为 1/0，如将 11110000(240) 的第四位(从低位开始)设为 1/0
```js
// 设置为 1
const setBit = (num, bitPosition) => num | (1 << bitPosition)

// 设置为 0
const clearBit = (num, bitPosition) => num & (~(1 << bitPosition))

// 合并上述两个操作
const updateBit = (num, bitPosition, bitValue) => {
  const bitValueNormalized = bitValue ? 1 : 0
  const clearMask = ~(1 << bitPosition)
  // 先清除指定位的值，再使用 | 设置新值
  return (num & clearMask) | (bitValueNormalized << bitPosition)
}
```




## 经典题目

### 只出现一次的数字

+ 问题1：一个数组中除了一个数字只出现一次外，其他均出现偶数次，找出只出现一次的数字
```js
/* 如: [12, 12, 11, 2, 2, 2, 2] => 11
   结合以下两点，我们就能写出问题解法：
   1. a^a === 0，a^0 === a
   2. 多个 ^ 之间不区分执行顺序

   也就是说，只要对数组的所有数字按顺序执行 ^ 操作，就能得到结果了！
*/

// 偷懒写法
const findOne = arr => eval(arr.join('^'))
const findOne = arr => arr.reduce((a, b) => a^b)

// 常规写法
const findOne = arr => {
  let i = arr.length - 1
  let ret = 0

  while (i >= 0) {
    ret ^= arr[i--]
  }

  return ret
}
```

