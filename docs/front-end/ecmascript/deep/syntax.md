---
sidebarDepth: 2
---

## 语法

+ `ECMAScript` 的语法大量借鉴了 `C` 语言和类 C 语言(`Java` 和 `Perl`)。并具有以下特点：


### 区分大小写

一切都区分大小写，彼此象征着不同的含义


### 标识符

标识符泛指变量名、函数名、属性名、函数参数名等，合格的标识符：
+ 必须以字母、下划线(_)、美元符号($)开头
+ 其他字符可以是字母、下划线、美元符号、数字等


::: tip 说明：
+ 除了开头限定外，其他字符可以是任意扩展的 Unicode 字符，甚至是中文字符
+ 驼峰命名(camel case, 如 `myCar`)或蛇形命名(snake case, 如 `my_car`)
:::



### 关键字和保留字

关键字和保留字的区别：
+ 关键字：具有特定用途
+ 保留字：在语言中还没有特定的用途，但是作为未来关键字的候选词



### 注释

+ 使用 `C` 风格的单行注释和多行注释

:::: tabs
::: tab 单行注释
```js
// 这是单行注释
var a = 1
var b = 2   // 这也是单行注释
```
:::

::: tab 多行注释
```js
/* 
  这是多行注释
 */
var a = 1

// 也可以这样写
/* 
 * 这是多行注释
 * 这样有利于提高可读性，但不是必须的
 */
var b = 2
```
:::
::::


### 严格模式

+ ES5 引入了严格模式，它是一种不同的解析与执行模型，针对 ES3 的一些不确定行为进行了处理(或抛出错误)
+ 提高编译器效率，增加运行速度，消除代码运行的一些不安全不合理之处，为新版本的 JavaScript 做铺垫
:::: tabs
::: tab 使用方式
+ 在整个脚本启用：
```js
'use strict'    // 它是脚本的第一行
```
+ 在指定函数内启用：
```js
function func() {
  'use strict'  // 它是函数体内的第一行
  // ...
}
```
:::

::: tab 严格模式的内容
+ 规范：
  + 变量必须先声明后使用
  + 不能对只读属性赋值，否则报错
  + 不能删除不可删除的属性，否则报错
  + 只能删除属性 `delete global[prop]`，不能删除变量 `delete prop`，否则报错
+ 更改特性：
  + `eval` 具有私有作用域（不再会修改同名的外部变量）
  + `eval` 和 `arguments` 不能被重新赋值
  + `arguments` 不会自动反映函数参数的变化
  + 函数参数不能有同名属性，否则报错
+ 增加：
  + 增加了保留字(`protected`, `static`, `interface`)
+ 抛弃：
  + 不能使用 `with`
  + 不能使用 `this` 指向 `window`
  + 不能使用 `arguments.callee`, `arguments.caller`
  + 不能使用 `fn.caller` 和 `fn.arguments` 获取函数调用的堆栈
  + 不能使用前缀 0 表示八进制数，否则报错
:::

::: tab 推荐使用
+ 不要使用 `with`
+ 尽量不要使用 `eval`
+ 尽量使用 ES6 的 `rest` 参数代替 `arguments`
:::
::::


### 语句

+ 使用分号(`;`)标识语句的结束，可以省略语句结尾的分号，因为解析器会自动添加分号
```js
var str = 'hello world';
var name = 'Zed'          // 省略分号
```

::: tip 要不要使用分号视个人/团队而定：
+ 建议不要省略分号：避免有时省略分号时出现错误、提高代码的性能(不用解析器去推测加入分号的地方)
+ 建议省略分号：代码简洁，代码性能影响不大，但要注意在一些场景下需要添加分号(一般为开头)：
  + 正则开头：很少遇见
  + `+`/`-`：很少遇见
  + 括号：一般在自执行函数(IIFE)出现
  + 方括号：一般在开头的解构赋值出现
```js
// 正则
let a = 2
;/\d+/

// +/-
let a = 2
;+2

// 分号
let a = 2

;(function () {
  console.log('hello')
})()

// 方括号
let a = 2
;[a] = [1]
```
:::

+ 使用花括号(`{}`)包裹代码块，可以省略只有一行代码的流程控制语句块的花括号
```js
if (flag) {
  console.log('true')
}
// 可以这样写
if (flag)
  console.log('true')

for (var i = 0; i < 3; i++) {
  console.log(i)
}
// 可以这样写
for (var i = 0; i < 3; i++)
  console.log(i)
```

::: tip 说明：
+ 不要省略花括号，尽管只有代码块内只有一行语句，这样有利于统一代码和提高可读性
:::



## 变量声明

### var

+ 使用关键字 `var` 声明一个变量：
```js
// 仅声明
var name

// 声明并赋值
var name = 'Zed'

// 声明和赋值分开
var name
name = 'Zed'

// 省略关键字 var
name = 'Zed'

// 同时声明多个变量
var name = 'Zed'
    age = 22
    sex = 'male'
```

::: tip 备注：
+ 永远不要省略关键字 `var`，这样能避免全局变量污染(省略关键字 `var` 时变量会上升为全局变量)
+ 尽量为已知类型的变量赋初始值，不推荐将变量声明和赋值分开
+ 推荐使用多行同时声明多个变量(不是必要)，这样有利于提高可读性
+ `ES6+` 基本抛弃了 `var` 关键字，而是使用 `let`/`const`
:::


### let/const

+ `let` 用于声明变量
+ `const` 用于声明常量，一旦声明便不可变(引用类型除外)，且声明常量时一定要赋值，否则报错
```js
let a = 12
const PI = 3.14
```
::: tip let/const 和 var 的区别：
+ 块级作用域：var 不存在块级作用域
+ 不存在变量提升：var 会发生变量提升
+ 不可重复声明：var 可重复声明变量
+ 暂时性死区(TDZ)：只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量
+ `let`/`const` 声明的全局变量不会挂在顶层对象下面：使用 var 声明的全局变量可以用 `global.a`/`window.a` 的形式获取，但使用 `let`/`const` 声明的则不行
:::


### 变量提升 & 函数提升

+ 变量提升：在同一作用域下，变量可以在声明之前使用，值为 `undefined`
+ 函数提升：使用函数声明方式定义的方法，调用语句可以在声明语句之前(解析器在代码开始执行前将函数提升到顶部)
```js
console.log(a) // undefined 
func() // world

var a = 'hello'
function func() { console.log('world') }
```

::: tip 备注：
+ 变量/常量的声明尽量使用 `let`/`const`，避免出现变量提升
:::


### 函数定义的方式

```js
// 1.函数声明
function func() {}

// 2.函数表达式
const func = function() {}

// 3.构造函数
const func = new Function('str', 'return str')
```

::: tip 备注：
+ 函数声明会提升，函数表达式不会
+ 构造函数模式会解析两次代码，影响性能，一般不会使用
:::