## 词法作用域 & 动态作用域

`Javascript` 中使用的是词法作用域(静态作用域)，他们的区别如下：
+ `词法作用域`：函数的作用域是在函数定义的时候决定的；变量的查找开始于最接近的绑定上下文而向外扩展，直到找到第一个绑定
+ `动态作用域`：函数的作用域是在函数调用的时候决定的；变量的查找开始于函数内部，接着到调用函数的作用域查找



## 作用域 & 作用域链

+ `作用域`：可以分为全局作用域和局部作用域；局部作用域由函数产生，所以也叫函数作用域
+ `作用域链`：当代码在一个环境中执行时，会创建变量对象的一个作用域链，它保证对执行环境有权访问的所有变量和函数的有序访问；内部环境很够通过作用域链访问所有的外部环境，反之则不能



## this & 执行上下文栈

**显式绑定：** `call()/bind()/apply()`

**隐式绑定：**
+ 全局上下文：默认 `this` 指向 `window`，严格模式下指向 `undefined`
+ 直接调用函数，相当于在全局上下文调用
+ `obj.func()` 调用：`this` 指向 `obj` 对象
+ `DOM` 事件绑定：`this` 指向绑定事件的元素
+ `new P()` 调用：`this` 指向实例对象
+ 箭头函数：`this` 指向最近的非箭头函数的 `this`，层层向上直至到达全局上下文

**this 绑定优先级：** `new` > `call()/bind()/apply()` > `obj.func()` > `func()`



## this 的原理 & 不同场景的取值

**this 的原理：**
+ 

**this 的取值：**
+ `setInterval()/setTimeout()` 中指向 `window`
+ `new` 中指向新创建的实例
+ `call()/bind()/apply()` 中指向绑定的对象
+ 函数调用时指向调用该函数的对象
+ 箭头函数中指向当前的环境上下文



## 什么是闭包 & 闭包优缺点

&emsp;&emsp;可以简单理解闭包为能够读取其他函数内部变量的函数。

**优点：**
+ 逻辑连续，当闭包作为另一个函数调用的参数时，避免你脱离当前逻辑而单独编写额外逻辑
+ 方便调用上下文的局部变量
+ 加强封装性，可以达到对变量的保护作用

**缺点：**
+ 使用闭包时，函数执行后不被销毁造成内存浪费，对闭包的使用不当会造成内存泄漏



## 闭包的实现原理 & 在开发中的应用

**实现原理：** 在执行环境中，内部环境能够通过作用域链访问外部环境

```js
function say(prefix) {
  return function (name) {
    console.log(`${prefix} ${name}`) // 捕获外部环境的 prefix 参数
  }
}

const sayHi = say('Hi!')
sayHi('Alice') // Hi Alice
```

**应用：**

+ 借助闭包可以动态创建一系列的工具函数：

```js
// 动态创建判断变量类型的工具函数
const isType = function(type) {
  return function(target) {
    return `[object ${type}]` === Object.prototype.toString.call(target)
  }
}
const isArray = isType('Array')
console.log(isArray([])) // true
const isNull = isType('Null')
console.log(isNull(null)) // true
```

+ 借助闭包模拟块级(私有)作用域

```js
// 结局 var 没有块级作用域的问题
for (var i = 1; i <= 5; i++) {
  (function(i) {
    setTimeout(function() {
      console.log(i)
    }, 1000 * i)
  })(i)
}

// 一些框架中避免污染全局变量而创建的块级作用域
(function(jQuery) { 
  // ...
})(jQuery)
```



## 堆栈溢出/内存泄漏的原理 & 如何防止

**内存泄漏：** 申请的内存执行完后没有及时的清理或者销毁，占用空闲内存，内存泄露过多会导致后面的程序申请不到内存

**堆栈溢出：** 内存空间已经被申请完，没有足够的内存提供

**内存泄露的原因：**
+ 全局变量
+ 闭包
+ 计时器/定时器

**解决：**
+ 较少不必要的全局变量
+ 减少闭包的使用
+ 在合适的时候清除计时器
+ 避免死循环



## 如何处理循环的异步操作

+ 使用闭包
+ 使用 `Promise`
+ 使用 `async/await`



## 模块化解决了什么 & 模块化方案对比

