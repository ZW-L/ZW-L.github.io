---
sidebarDepth: 2
---

## 基本类型和引用类型

### 区别 

+ 基本数据类型：按值访问。值保存在栈中，操作的是实际的值
+ 引用数据类型：按引用访问。值保存在堆中，值引用保存在栈中，操作的是值的引用


### 动态属性

+ 可以给数据类型添加属性，但是给基本数据类型添加属性时，并不能访问：
```js
// 给基本类型添加属性
var name = 'Seven'
name.age = 24
console.log(name.age)  // undefined

// 给引用类型添加属性
var obj = {}
obj.name = 'Seven'
console.log(obj.name) // Seven
```


### 变量的复制

+ 基本数据类型的复制会创建一个新的互不影响的副本
```js
var a = 12
var b = a

b = 10
console.log(a, b)     // 12 10
```
+ 引用数据类型的复制只能拷贝值的引用，属于浅拷贝，在任何一个引用中修改值，都会改变所有引用的副本
```js
var obj = { name: 'Seven' }
var obj2 = obj

obj2.name = 'Anna'
console.log(obj.name, obj2.name)  // Anna Anna
```


### 参数传递

+ 尽管访问变量可以通过按值访问(基本数据类型)和按引用访问(引用类型)，但是参数的传递只是按值传递的；即使传递的是一个对象，传递的也是保存该对象的引用的值
+ 误以为参数传递是按引用传递的例子：
```js
var obj = { name: 'Seven' }
function setName(obj) {
  obj.name = 'Anna'
}

setName(obj)
console.log(obj.name)   // 'Anna'
```
+ 证明参数传递是按值传递的例子：
```js
function setName(obj) {
  obj.name = 'Alice'
  obj = new Object()
  obj.name = 'Anna'
}

var obj = new Object()
setName(obj)
console.log(obj.name)   // 'Alice'
```

::: tip 解析：
+ 传递对象时，参数传递的是一个该对象的内存指向的指针值，在该指针上操作对象时会直接影响对象的属性
+ 但在函数内部用一个新的对象给 obj 指针赋值时，此时的 obj 指向的是新对象，在它之后的操作只会影响新对象，不会影响原来的对象
+ 说明传递对象时只会传递一个指针值而不是传递一个完全的对象引用
:::



## 垃圾收集

### 垃圾回收机制

Javascript 有自动的垃圾回收机制，浏览器的实现方式主要有两种：
+ 标记清除法：当变量在一个环境中被创建时，会被标记为 "进入环境"，当其离开环境时，会被标记为 "离开环境"，垃圾回收器会定时对标记为 "离开环境" 的变量进行回收；**是目前大多数浏览器使用的是该种方式**
+ `引用计数法`：该方法跟踪记录每个值被引用的次数，当一个值被一个变量引用时，它的引用次数就会加 1，当一个变量解除对它的引用时，它的引用次数就会减 1，垃圾回收器会定时对引用次数为 0 的值进行回收；**因为容易遇到一个循环引用的问题，该方式很少被使用**

::: tip 备注：
+ IE9 之前的版本中的 `BOM` 和 `DOM` 对象是使用 `C++` 以 `COM` 的形式实现的，`COM` 对象的垃圾回收机制采用的就是引用计数法，因此在 IE 中涉及 `COM` 的情况下，都会容易发生循环引用的内存问题
+ 解决循环引用的方式是手动断开变量和对象的链接，将变量赋值为 `null`
:::


### 性能问题

+ 有的浏览器能够手动触发垃圾收集过程，但是不建议使用
+ 在数据不再使用的情况下，将其设置为 `null` 来释放引用(称为解除引用)是更好的
+ 解除引用的作用是让值退出环境，不代表内存马上会被释放，因为垃圾回收器是定时执行的
+ **内存泄漏：** 申请的内存执行完后没有及时的清理或者销毁，占用空闲内存，内存泄露过多会导致后面的程序申请不到内存
+ **堆栈溢出：** 内存空间已经被申请完，没有足够的内存提供
+ **内存泄露的原因：**
  + 全局变量
  + 闭包
  + 计时器/定时器
+ **解决：**
  + 较少不必要的全局变量
  + 减少闭包的使用
  + 在合适的时候清除计时器
  + 避免死循环